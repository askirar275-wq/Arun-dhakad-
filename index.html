<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Smooth Cut Line</title>
<style>
:root{
  --ui:#f4f7fb; --panel:#efe9e1; --btn:#111; --accent:#22c55e;
  --hud-shadow: 0 8px 22px rgba(0,0,0,0.06);
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;background:var(--ui);font-family:Inter,system-ui,Roboto,Arial,sans-serif;color:#111}
.container{max-width:920px;margin:0 auto;padding:12px}
h1{text-align:center;margin:8px 0}
.hud{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-bottom:10px}
.stat{background:#fff;padding:8px 12px;border-radius:12px;box-shadow:var(--hud-shadow);font-weight:700}
#gameWrapper{position:relative;border-radius:14px;overflow:hidden;height:66vh;min-height:480px;background:linear-gradient(180deg,#bfe9ff,#f6f7fb)}
#sky{position:absolute;inset:0;z-index:1}
#gameArea{position:absolute;inset:0;z-index:2;touch-action:none}
canvas{position:absolute;inset:0;z-index:6}
.fruit, .half{position:absolute;transform:translate(-50%,-50%);user-select:none;pointer-events:none;z-index:5}
#bigStart{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:12;background:var(--btn);color:#fff;padding:14px 20px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 12px 34px rgba(0,0,0,0.25)}
.controls{display:flex;gap:12px;justify-content:center;padding:18px;margin-top:6px}
.btn{background:#fff;border:0;padding:10px 18px;border-radius:12px;cursor:pointer;box-shadow:0 10px 26px rgba(2,6,23,0.06);font-weight:700}
.btn.ghost{background:transparent;border:1px solid rgba(0,0,0,0.06)}
#gameOver{position:absolute;inset:0;z-index:1400;display:none;align-items:center;justify-content:center}
.card{background:#fff;padding:16px;border-radius:12px;box-shadow:0 12px 36px rgba(2,6,23,0.12)}
.modal{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:1500;display:none}
.shopGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px}
.shopItem{background:#fff;padding:8px;border-radius:8px;display:flex;align-items:center;gap:8px;justify-content:space-between}
.thumb{width:64px;height:44px;object-fit:cover;border-radius:8px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 14px;border-radius:999px;z-index:1600;display:none}
.loadingOverlay{position:absolute;inset:0;background:rgba(255,255,255,0.9);z-index:2000;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
.progress{width:70%;max-width:420px;background:#fff;padding:18px;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,0.08);text-align:center}
.progressBar{height:10px;background:#eee;border-radius:999px;overflow:hidden;margin:10px 0}
.progressFill{height:100%;width:0;background:linear-gradient(90deg,#22c55e,#06b6d4)}
.loadingEmoji{font-size:42px}
.hidden{display:none}
.small{font-size:13px;color:#666}
#hitFlash{position:absolute;inset:0;z-index:1401;pointer-events:none;background:radial-gradient(120% 120% at 50% 40%, rgba(255,80,80,0.22), rgba(0,0,0,0));opacity:0;transition:opacity .12s}
#hitFlash.show{opacity:1}
@media (max-width:720px){ #gameWrapper{height:62vh;min-height:420px} .thumb{width:56px;height:40px} }
</style>
</head>
<body>
<div class="container">
  <h1>üçâ Fruit Cut ‚Äî Final </h1>

  <div class="hud">
    <div class="stat">Score: <strong id="score">0</strong></div>
    <div class="stat">Lives: <strong id="lives">3</strong></div>
    <div class="stat">Coins: <strong id="coins">0</strong></div>
    <div style="flex:1"></div>
    <div class="stat">Level: <strong id="level">1</strong></div>
  </div>

  <div id="gameWrapper">
    <div id="sky"></div>
    <div id="gameArea" aria-label="game area"></div>
    <canvas id="gameCanvas"></canvas>
    <canvas id="bladeCanvas"></canvas>
    <canvas id="particles"></canvas>

    <div class="loadingOverlay" id="loader">
      <div class="progress">
        <div class="loadingEmoji" id="loadEmoji">üçâ</div>
        <div id="loadText">Loading images...</div>
        <div class="progressBar"><div class="progressFill" id="progressFill"></div></div>
        <div class="small" id="progressCount">0 / 0</div>
      </div>
    </div>

    <div id="bigStart">START</div>

    <div id="gameOver">
      <div class="card" style="text-align:center">
        <h2>Game Over</h2>
        <p>Score: <strong id="goScore">0</strong></p>
        <p>Best: <strong id="goBest">0</strong></p>
        <div style="margin-top:12px">
          <button id="goRestart" class="btn">Play Again</button>
        </div>
      </div>
    </div>

    <div id="hitFlash"></div>

    <!-- Shop modal -->
    <div id="shopModal" class="modal">
      <div class="card" style="min-width:320px;max-width:92vw">
        <h3 style="margin:0 0 8px">Shop ‚Äî Backgrounds / Blades</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <div class="small">Coins: <strong id="shopCoins">0</strong></div>
          <div style="flex:1"></div>
          <button id="closeShop" class="btn">Close</button>
        </div>

        <div style="margin-top:6px"><strong>Backgrounds</strong></div>
        <div class="shopGrid" id="bgGrid" style="margin:8px 0"></div>

        <div style="margin-top:6px"><strong>Blade skins</strong></div>
        <div class="shopGrid" id="bladeGrid" style="margin:8px 0"></div>
      </div>
    </div>

  </div>

  <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
    <button id="startBtn" class="btn">Start</button>
    <button id="pauseBtn" class="btn">Pause</button>
    <button id="restartBtn" class="btn">Restart</button>
    <button id="shopBtn" class="btn">Shop</button>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(() => {
  // ---------------------------
  // Config / assets
  // ---------------------------
  const IMAGE_ASSETS = {
    fruits: [
      { name:'apple', file:'images/apple.png', emoji:'üçé' },
      { name:'banana', file:'images/banana.png', emoji:'üçå' },
      { name:'orange', file:'images/orange.png', emoji:'üçä' },
      { name:'pear', file:'images/pear.png', emoji:'üçê' },
      { name:'grapes', file:'images/grapes.png', emoji:'üçá' },
      { name:'straw', file:'images/strawberry.png', emoji:'üçì' },
      { name:'kiwi', file:'images/kiwi.png', emoji:'ü•ù' }
    ],
    bomb: { name:'bomb', file:'images/bomb.png', emoji:'üí£' },
    powerups: [
      { name:'slow', file:'images/slow.png', emoji:'üê¢' },
      { name:'double', file:'images/double.png', emoji:'‚ú®' },
      { name:'shield', file:'images/shield.png', emoji:'üõ°Ô∏è' }
    ]
  };

  // DOM refs
  const gameWrapper = document.getElementById('gameWrapper');
  const gameCanvas = document.getElementById('gameCanvas');
  const bladeCanvas = document.getElementById('bladeCanvas');
  const particlesCanvas = document.getElementById('particles');
  const loader = document.getElementById('loader');
  const progressFill = document.getElementById('progressFill');
  const progressCount = document.getElementById('progressCount');
  const loadEmoji = document.getElementById('loadEmoji');

  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const coinsEl = document.getElementById('coins');
  const levelEl = document.getElementById('level');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const shopBtn = document.getElementById('shopBtn');
  const bigStart = document.getElementById('bigStart');
  const gameOver = document.getElementById('gameOver');
  const goRestart = document.getElementById('goRestart');
  const goScore = document.getElementById('goScore');
  const goBest = document.getElementById('goBest');
  const toastEl = document.getElementById('toast');
  const hitFlash = document.getElementById('hitFlash');

  const bgGrid = document.getElementById('bgGrid');
  const bladeGrid = document.getElementById('bladeGrid');
  const shopCoins = document.getElementById('shopCoins');
  const closeShop = document.getElementById('closeShop');

  // canvases and contexts
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  let gCtx, bladeCtx, pCtx;
  function initContexts(){
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const rect = gameWrapper.getBoundingClientRect();
    [gameCanvas, bladeCanvas, particlesCanvas].forEach(c => {
      c.width = Math.floor(rect.width * DPR);
      c.height = Math.floor(rect.height * DPR);
      c.style.width = rect.width + 'px';
      c.style.height = rect.height + 'px';
    });
    gCtx = gameCanvas.getContext('2d', { alpha:true });
    bladeCtx = bladeCanvas.getContext('2d', { alpha:true });
    pCtx = particlesCanvas.getContext('2d', { alpha:true });
    gCtx.setTransform(DPR,0,0,DPR,0,0);
    bladeCtx.setTransform(DPR,0,0,DPR,0,0);
    pCtx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', () => initContexts());

  initContexts();

  // ---------------------------
  // Game state
  // ---------------------------
  let running = false;
  let paused = false;

  let score = 0;
  let lives = 3;
  let coins = 0;
  let level = 1;

  let best = Number(localStorage.getItem('fc_best_v1') || 0);

  // physics / spawn
  const BASE = { GRAV: 1100, VY_MIN: -900, VY_MAX: -700, VX: 200 };
  let spawnTimer = 0;

  // collections
  let fruits = [];
  let pieces = [];
  let particles = [];
  // blade raw points and smoothed path
  let bladePoints = []; // {x,y,t}
  let smoothPoints = []; // smoothed for drawing

  // preloaded images
  const images = { fruits: {}, bomb: null, powerups: {} };

  // shop & skins
  const BACKGROUNDS = [
    { id:'neon', name:'Neon', cost:0, css:'linear-gradient(180deg,#bfe9ff,#f6f7fb)' },
    { id:'wood', name:'Wood', cost:15, css:`url("data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256'><rect width='256' height='256' fill="#e9ddcf"/><g fill='none' stroke='#c8b59b' stroke-width='3'><path d='M0 40 C60 20 120 60 180 40 C220 28 250 38 256 36'/><path d='M0 120 C60 100 120 140 180 120 C220 108 250 118 256 116'/></g></svg>`) }` }
  ];
  const BLADES = [
    { id:'neon', name:'Neon', cost:0, color:'rgba(34,197,94,' },
    { id:'fire', name:'Fire', cost:25, color:'rgba(255,99,71,' },
    { id:'ice', name:'Ice',  cost:35, color:'rgba(102,204,255,' }
  ];

  let shopState = JSON.parse(localStorage.getItem('fc_shop_v1') || '{}');
  if(!shopState.purchasedBackgrounds) shopState.purchasedBackgrounds = [];
  if(!shopState.purchasedBlades) shopState.purchasedBlades = [];
  if(!shopState.selectedBg) shopState.selectedBg = BACKGROUNDS[0].id;
  if(!shopState.selectedBlade) shopState.selectedBlade = BLADES[0].id;
  if(shopState.coins == null) shopState.coins = 0;
  if(shopState.shieldActive == null) shopState.shieldActive = false;
  coins = shopState.coins || coins;

  // ---------------------------
  // Utility & helpers
  // ---------------------------
  function rand(a,b){ return a + Math.random()*(b-a); }
  function choose(arr){ return arr[(Math.random()*arr.length)|0]; }
  function showToast(msg, t=1100){ toastEl.textContent = msg; toastEl.style.display='block'; setTimeout(()=> toastEl.style.display='none', t); }

  // ---------------------------
  // Preload images from IMAGE_ASSETS
  // ---------------------------
  async function loadImage(src, timeoutMs=3000){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload = ()=>res(img);
      img.onerror = ()=>rej(new Error('load failed ' + src));
      img.src = src;
      // timeout fallback
      setTimeout(()=>{ if(!img.complete) rej(new Error('timeout ' + src)); }, timeoutMs);
    });
  }

  async function preloadImages(timeoutMs = 3000){
    const list = [];
    IMAGE_ASSETS.fruits.forEach(it => list.push({type:'fruit', key:it.name, file:it.file, emoji:it.emoji}));
    list.push({type:'bomb', key:'bomb', file:IMAGE_ASSETS.bomb.file, emoji:IMAGE_ASSETS.bomb.emoji});
    IMAGE_ASSETS.powerups.forEach(it => list.push({type:'power', key:it.name, file:it.file, emoji:it.emoji}));

    progressCount.textContent = `0 / ${list.length}`;
    progressFill.style.width = '0%';
    loadEmoji.textContent = 'üçâ';
    let loaded = 0;
    for(const item of list){
      try{
        const img = await loadImage(item.file, timeoutMs);
        if(item.type === 'fruit') images.fruits[item.key] = img;
        else if(item.type === 'bomb') images.bomb = img;
        else if(item.type === 'power') images.powerups[item.key] = img;
      }catch(e){
        if(item.type === 'fruit') images.fruits[item.key] = null;
        else if(item.type === 'bomb') images.bomb = null;
        else if(item.type === 'power') images.powerups[item.key] = null;
        console.warn('Image missing or failed:', item.file, e.message);
      }
      loaded++;
      progressCount.textContent = `${loaded} / ${list.length}`;
      progressFill.style.width = `${Math.round(loaded/list.length*100)}%`;
      loadEmoji.textContent = choose(IMAGE_ASSETS.fruits.map(f=>f.emoji));
      await new Promise(r=>setTimeout(r, 60));
    }
  }

  // ---------------------------
  // Entity constructors
  // ---------------------------
  function createFruit(opts){
    return {
      alive:true,
      x: opts.x, y: opts.y, vx: opts.vx, vy: opts.vy,
      r: opts.r || rand(20,36),
      emoji: opts.emoji,
      img: opts.img || null,
      type: opts.type || 'fruit',
      rot: opts.rot || rand(-0.06,0.06)
    };
  }

  function createPiece(emoji, x, y, vx, vy, r){
    return { emoji, x, y, vx, vy, r, life: 30 + Math.random()*18, rot: rand(-0.12,0.12) };
  }

  function createParticle(x,y,vx,vy,life,r){
    return { x,y,vx,vy,life,r };
  }

  // ---------------------------
  // Spawn / game logic
  // ---------------------------
  function spawnCluster(){
    const rect = gameCanvas.getBoundingClientRect();
    const baseX = rand(0.2*rect.width, 0.8*rect.width);
    const cluster = Math.random() < 0.12 ? 2 : 1;
    for(let i=0;i<cluster;i++){
      const isBomb = Math.random() < 0.10;
      const entry = isBomb ? IMAGE_ASSETS.bomb : choose(IMAGE_ASSETS.fruits);
      const img = isBomb ? images.bomb : images.fruits[entry.name];
      const obj = createFruit({
        x: baseX + rand(-80,80),
        y: rect.height + 40 + Math.random()*20,
        vx: rand(-BASE.VX, BASE.VX),
        vy: rand(BASE.VY_MIN, BASE.VY_MAX),
        r: isBomb ? rand(20,36) : rand(28,44),
        emoji: entry.emoji,
        img: img,
        type: isBomb ? 'bomb' : 'fruit',
        rot: rand(-0.06,0.06)
      });
      fruits.push(obj);
    }
  }

  // ---------------------------
  // Input: trails / smoothing
  // ---------------------------
  let pointerDown = false;
  function addPoint(x,y){
    bladePoints.push({x,y,t:Date.now()});
    if(bladePoints.length > 80) bladePoints.shift();
  }

  function onPointerMove(e){
    const rect = gameCanvas.getBoundingClientRect();
    let x, y;
    if(e.touches && e.touches[0]){ x = e.touches[0].clientX - rect.left; y = e.touches[0].clientY - rect.top; }
    else { x = e.clientX - rect.left; y = e.clientY - rect.top; }
    if(e.type === 'pointerdown' || e.type === 'touchstart' || e.type === 'mousedown'){ pointerDown = true; addPoint(x,y); }
    else if(e.type === 'pointerup' || e.type === 'touchend' || e.type === 'mouseup'){ pointerDown = false; bladePoints = []; smoothPoints = []; }
    else if(pointerDown) addPoint(x,y);
  }

  window.addEventListener('pointermove', onPointerMove, {passive:true});
  window.addEventListener('pointerdown', onPointerMove);
  window.addEventListener('pointerup', ()=> { pointerDown=false; bladePoints=[]; smoothPoints=[]; });

  // ---------------------------
  // Slicing detection
  // ---------------------------
  let lifeCooldown = 0;
  function distToSeg(px,py,x1,y1,x2,y2){
    const dx = x2-x1, dy = y2-y1;
    const l2 = dx*dx + dy*dy || 1;
    let t = ((px-x1)*dx + (py-y1)*dy)/l2; t = Math.max(0, Math.min(1,t));
    const cx = x1 + dx*t, cy = y1 + dy*t;
    return Math.hypot(px-cx, py-cy);
  }

  function checkSlicing(){
    if(bladePoints.length < 2) return;
    const pts = bladePoints.slice(-20);
    for(let s=0; s<pts.length-1; s++){
      const a = pts[s], b = pts[s+1];
      for(let i=fruits.length-1;i>=0;i--){
        const f = fruits[i];
        const d = distToSeg(f.x, f.y, a.x, a.y, b.x, b.y);
        if(d < f.r*0.6){
          if(f.type === 'bomb'){
            if(lifeCooldown <= 0){
              if(shopState.shieldActive){ shopState.shieldActive = false; showToast('Shield used'); }
              else { lives = Math.max(0, lives-1); hitFlash.classList.add('show'); setTimeout(()=>hitFlash.classList.remove('show'), 140); }
              lifeCooldown = 0.45;
            }
            fruits.splice(i,1);
            continue;
          }
          fruits.splice(i,1);
          score += 1; coins += 1; shopState.coins = coins;
          pieces.push(createPiece(f.emoji, f.x-6, f.y, f.vx-2.2, f.vy-1.8, f.r));
          pieces.push(createPiece(f.emoji, f.x+6, f.y, f.vx+2.2, f.vy-1.8, f.r));
          for(let p=0;p<12;p++) particles.push(createParticle(f.x, f.y, rand(-3,3)*20, rand(-6,-1)*20, rand(18,36), rand(2,4)));
          updateHUD();
        }
      }
    }
  }

  // ---------------------------
  // Trail smoothing algorithm
  // - We'll build smoothPoints from bladePoints by:
  //   1) downsampling to at most N points
  //   2) applying exponential smoothing (lerp) to reduce jitter
  //   3) drawing a smooth quadratic path using midpoints (catmull-like)
  // ---------------------------
  const MAX_DRAW_POINTS = 28;        // max points used to draw curve
  const SMOOTHING_FACTOR = 0.22;     // lerp factor for smoothing (0..1) lower = more inertia
  function buildSmoothPoints(){
    // downsample raw points by picking equidistant indices (latest points)
    if(bladePoints.length === 0){ smoothPoints = []; return; }
    const raw = bladePoints.slice(-Math.min(bladePoints.length, 60));
    const step = Math.max(1, Math.floor(raw.length / MAX_DRAW_POINTS));
    const sampled = [];
    for(let i=0;i<raw.length;i+=step){
      sampled.push({x: raw[i].x, y: raw[i].y});
    }
    // ensure last is present
    if(sampled.length === 0 && raw.length) sampled.push({x:raw[raw.length-1].x, y:raw[raw.length-1].y});
    else if(raw.length) sampled[sampled.length-1] = {x: raw[raw.length-1].x, y: raw[raw.length-1].y};

    // apply exponential smoothing: smoothPoints morphs towards sampled
    if(smoothPoints.length === 0){
      // initialize
      smoothPoints = sampled.map(p => ({x:p.x, y:p.y}));
    } else {
      // if sizes differ, align by keeping tail
      const targetLen = sampled.length;
      if(smoothPoints.length > targetLen) smoothPoints = smoothPoints.slice(smoothPoints.length - targetLen);
      else if(smoothPoints.length < targetLen){
        // prepend copies of first to match length
        const need = targetLen - smoothPoints.length;
        const first = smoothPoints[0] || sampled[0];
        for(let k=0;k<need;k++) smoothPoints.unshift({x:first.x, y:first.y});
      }
      // now lerp each
      for(let i=0;i<targetLen;i++){
        const s = sampled[i];
        smoothPoints[i].x += (s.x - smoothPoints[i].x) * SMOOTHING_FACTOR;
        smoothPoints[i].y += (s.y - smoothPoints[i].y) * SMOOTHING_FACTOR;
      }
    }
  }

  // function to draw smooth trail (multi-layer glow)
  function drawSmoothTrail(ctx){
    if(smoothPoints.length < 2) return;
    // create path via quadratic midpoints:
    ctx.save();
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    // glow layers: from wide faint to narrow bright
    const layers = [
      { width: 22, alpha: 0.08, blur: 18 },
      { width: 12, alpha: 0.13, blur: 8 },
      { width: 6, alpha: 0.9, blur: 0 }
    ];
    const blade = BLADES.find(b=>b.id === shopState.selectedBlade) || BLADES[0];
    const colorBase = blade.color || 'rgba(34,197,94,';
    for(const L of layers){
      ctx.strokeStyle = colorBase + L.alpha + ')';
      ctx.lineWidth = L.width;
      if(L.blur){
        ctx.shadowColor = colorBase + (L.alpha*0.9) + ')';
        ctx.shadowBlur = L.blur;
      } else {
        ctx.shadowBlur = 0;
      }
      ctx.beginPath();
      const pts = smoothPoints;
      // move to first
      ctx.moveTo(pts[0].x, pts[0].y);
      // for each middle point, draw quadratic curve to midpoint
      for(let i=1;i<pts.length;i++){
        const prev = pts[i-1], cur = pts[i];
        const midx = (prev.x + cur.x) / 2;
        const midy = (prev.y + cur.y) / 2;
        ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
      }
      // final curve to last point
      const last = pts[pts.length-1];
      ctx.lineTo(last.x, last.y);
      ctx.stroke();
    }
    // crisp core line
    ctx.strokeStyle = 'rgba(255,255,255,0.66)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(smoothPoints[0].x, smoothPoints[0].y);
    for(let i=1;i<smoothPoints.length;i++){
      const prev = smoothPoints[i-1], cur = smoothPoints[i];
      const midx = (prev.x + cur.x) / 2;
      const midy = (prev.y + cur.y) / 2;
      ctx.quadraticCurveTo(prev.x, prev.y, midx, midy);
    }
    ctx.lineTo(smoothPoints[smoothPoints.length-1].x, smoothPoints[smoothPoints.length-1].y);
    ctx.stroke();

    ctx.restore();
  }

  // ---------------------------
  // Update / Draw loop
  // ---------------------------
  function update(dt){
    // spawn control (frame-based)
    spawnTimer -= dt * 60;
    if(spawnTimer <= 0){
      spawnCluster();
      spawnTimer = Math.max(6, 22 - Math.floor(level*1.1) + Math.floor(Math.random()*8));
    }

    // gravity (frame normalized)
    const GRAV = BASE.GRAV/60;

    // update fruits
    const rect = gameCanvas.getBoundingClientRect();
    for(let i=fruits.length-1;i>=0;i--){
      const f = fruits[i];
      f.vy += GRAV * dt * 60;
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.rot += 0.001*dt;
      if(f.y - f.r > rect.height + 80){
        fruits.splice(i,1);
        lives = Math.max(0, lives-1);
      }
    }

    // pieces
    for(let i=pieces.length-1;i>=0;i--){
      const p = pieces[i];
      p.vy += (GRAV*0.9) * dt * 60;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt*60;
      if(p.life <= 0) pieces.splice(i,1);
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){
      const pr = particles[i];
      pr.vy += 0.18 * dt * 60;
      pr.x += pr.vx * dt;
      pr.y += pr.vy * dt;
      pr.life -= dt*60;
      if(pr.life <= 0) particles.splice(i,1);
    }

    // prune old bladePoints (>220ms)
    const nowt = Date.now();
    bladePoints = bladePoints.filter(pt => nowt - pt.t < 220);

    // life cooldown
    lifeCooldown = Math.max(0, lifeCooldown - dt);

    // build smooth points from bladePoints
    buildSmoothPoints();

    // slicing detection
    checkSlicing();

    // level update
    const newLevel = Math.floor(score/20) + 1;
    if(newLevel !== level){ level = newLevel; levelEl.textContent = level; showToast('Level ' + level); }
  }

  function draw(){
    const rect = gameCanvas.getBoundingClientRect();
    gCtx.clearRect(0,0,rect.width, rect.height);
    bladeCtx.clearRect(0,0,rect.width, rect.height);
    pCtx.clearRect(0,0,rect.width, rect.height);

    // fruits
    for(const f of fruits){
      gCtx.save(); gCtx.translate(f.x, f.y); gCtx.rotate(f.rot);
      if(f.img && f.img.complete){
        const d = f.r*2;
        gCtx.drawImage(f.img, -d/2, -d/2, d, d);
      } else {
        gCtx.font = Math.floor(f.r) + 'px serif';
        gCtx.textAlign='center'; gCtx.textBaseline='middle';
        gCtx.fillText(f.emoji, 0, 0);
      }
      gCtx.restore();
    }

    // pieces
    for(const p of pieces){
      pCtx.save(); pCtx.translate(p.x, p.y); pCtx.rotate(p.rot);
      pCtx.font = Math.floor(p.r) + 'px serif';
      pCtx.textAlign='center'; pCtx.textBaseline='middle';
      pCtx.fillText(p.emoji, 0, 0);
      pCtx.restore();
    }

    // particles
    for(const pr of particles){
      pCtx.beginPath();
      pCtx.globalAlpha = Math.max(0, pr.life/60);
      pCtx.fillStyle = 'rgba(255,200,80,0.95)';
      pCtx.arc(pr.x, pr.y, pr.r, 0, Math.PI*2);
      pCtx.fill();
      pCtx.globalAlpha = 1;
    }

    // draw smooth blade trail (bladeCtx)
    drawSmoothTrail(bladeCtx);
  }

  // physics tick
  let last = performance.now();
  function physicsTick(){
    const now = performance.now();
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    if(running && !paused){ update(dt); draw(); }
    requestAnimationFrame(physicsTick);
  }

  // ---------------------------
  // HUD / shop / save
  // ---------------------------
  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    coinsEl.textContent = coins;
    levelEl.textContent = level;
    shopCoins.textContent = coins;
  }

  function saveShop(){
    shopState.coins = coins;
    localStorage.setItem('fc_shop_v1', JSON.stringify(shopState));
  }

  function updateShopUI(){
    bgGrid.innerHTML = '';
    BACKGROUNDS.forEach(b => {
      const div = document.createElement('div'); div.className='shopItem';
      div.innerHTML = `<div>${b.name}</div><div><button class="btn" data-bg="${b.id}">${shopState.purchasedBackgrounds && shopState.purchasedBackgrounds.includes(b.id)?'Apply':('Buy ' + b.cost)}</button></div>`;
      bgGrid.appendChild(div);
    });
    bladeGrid.innerHTML = '';
    BLADES.forEach(bl => {
      const div = document.createElement('div'); div.className='shopItem';
      div.innerHTML = `<div>${bl.name}</div><div><button class="btn" data-bl="${bl.id}">${shopState.purchasedBlades && shopState.purchasedBlades.includes(bl.id)?'Equip':('Buy ' + bl.cost)}</button></div>`;
      bladeGrid.appendChild(div);
    });

    // bg buttons
    bgGrid.querySelectorAll('button').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-bg');
        const item = BACKGROUNDS.find(x=>x.id===id);
        if(shopState.purchasedBackgrounds && shopState.purchasedBackgrounds.includes(id)){ applyBackground(id); saveShop(); showToast('Background applied'); }
        else if(coins >= item.cost){ coins -= item.cost; shopState.purchasedBackgrounds.push(id); applyBackground(id); saveShop(); updateHUD(); updateShopUI(); showToast('Purchased'); }
        else showToast('Not enough coins');
      };
    });
    bladeGrid.querySelectorAll('button').forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute('data-bl');
        const item = BLADES.find(x=>x.id===id);
        if(shopState.purchasedBlades && shopState.purchasedBlades.includes(id)){ shopState.selectedBlade = id; saveShop(); showToast('Blade equipped'); }
        else if(coins >= item.cost){ coins -= item.cost; shopState.purchasedBlades.push(id); shopState.selectedBlade = id; saveShop(); updateHUD(); updateShopUI(); showToast('Purchased'); }
        else showToast('Not enough coins');
      };
    });
  }

  function applyBackground(bgId){
    const bg = BACKGROUNDS.find(b=>b.id===bgId) || BACKGROUNDS[0];
    gameWrapper.style.background = bg.css;
    shopState.selectedBg = bg.id;
    saveShop();
  }

  // ---------------------------
  // Start / pause / restart
  // ---------------------------
  function startGame(auto=false){
    if(!running){
      running = true;
      paused = false;
    }
    if(!auto){
      fruits = []; pieces = []; particles = []; bladePoints = []; smoothPoints = [];
      score = 0; lives = 3; coins = shopState.coins || 0; level = 1;
    }
    bigStart.style.display = 'none';
    gameOver.style.display = 'none';
    updateHUD();
  }

  function pauseGame(){
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }

  function restartGame(){
    running = true;
    paused = false;
    fruits = []; pieces = []; particles = []; bladePoints = []; smoothPoints = [];
    score = 0; lives = 3; level = 1; spawnTimer = 0; updateHUD();
    gameOver.style.display = 'none';
    bigStart.style.display = 'none';
  }

  function endGame(){
    running = false;
    gameOver.style.display = 'flex';
    goScore.textContent = score;
    best = Math.max(best, score);
    goBest.textContent = best;
    localStorage.setItem('fc_best_v1', best);
    showToast('Game Over');
  }

  // ---------------------------
  // Bind UI actions
  // ---------------------------
  startBtn.addEventListener('click', ()=> startGame(false));
  bigStart.addEventListener('click', ()=> startGame(false));
  pauseBtn.addEventListener('click', ()=> pauseGame());
  restartBtn.addEventListener('click', ()=> restartGame());
  shopBtn.addEventListener('click', ()=> { updateShopUI(); document.getElementById('shopModal').style.display='block'; });
  closeShop.addEventListener('click', ()=> document.getElementById('shopModal').style.display='none');
  goRestart.addEventListener('click', ()=> { document.getElementById('gameOver').style.display='none'; restartGame(); });

  // ---------------------------
  // Init + preload + start loop
  // ---------------------------
  function startEmojiCycle(){
    const EMOJIS = ['üçâ','üçä','üçå','üçì','üçç','ü•ù','üçé'];
    let i=0;
    window._eI = setInterval(()=>{ loadEmoji.textContent = EMOJIS[i%EMOJIS.length]; i++; }, 450);
  }
  function stopEmojiCycle(){ if(window._eI){ clearInterval(window._eI); window._eI = null; } }

  async function init(){
    initContexts();
    startEmojiCycle();
    loader.style.display = 'flex';
    try{
      await preloadImages(3000);
    }catch(e){
      console.warn('preload issues', e);
    }
    stopEmojiCycle();
    loader.style.display = 'none';
    if(!shopState.purchasedBackgrounds) shopState.purchasedBackgrounds = [shopState.selectedBg];
    if(!shopState.purchasedBlades) shopState.purchasedBlades = [shopState.selectedBlade];
    applyBackground(shopState.selectedBg || BACKGROUNDS[0].id);
    updateShopUI();
    updateHUD();
    last = performance.now();
    physicsTick();
    setTimeout(()=>{ if(!running) startGame(true); }, 300);
  }

  window.addEventListener('load', init);

  // small API & debug
  window.FruitCut = { start: ()=>startGame(false), pause: ()=>pauseGame(), restart: ()=>restartGame(), shop: ()=> { updateShopUI(); document.getElementById('shopModal').style.display='block'; } };
  window._fc = { fruits, particles, pieces, shopState, images };

})();
</script>
</body>
</html>
