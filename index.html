<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Shooter — AutoFire + 2D Swipe + Boss after 50</title>
<style>
  :root{--accent:#7ef9ff;--accent2:#b388ff;--glass:rgba(255,255,255,0.06)}
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0;background:#000;font-family:Inter,system-ui,Arial;color:#eafcff}
  .wrap{height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  #gameContainer{width:100%;max-width:1100px;height:100%;max-height:820px;background:linear-gradient(180deg,#030214,#001028);border-radius:12px;position:relative;overflow:hidden;border:2px solid rgba(255,255,255,0.03)}
  canvas{display:block;width:100%;height:100%}
  .hud{position:absolute;left:12px;top:12px;z-index:40;display:flex;gap:10px;align-items:center}
  .chip{padding:8px 12px;border-radius:10px;background:var(--glass);border:2px solid rgba(255,255,255,0.04);font-weight:700}
  .controls{position:absolute;right:12px;top:12px;display:flex;gap:8px;z-index:40}
  .btn{padding:10px 12px;border-radius:12px;border:2px solid var(--accent);background:transparent;color:var(--accent);font-weight:700;cursor:pointer;transition:transform .12s;outline:none}
  .btn.secondary{border-color:var(--accent2);color:var(--accent2)}
  .btn:active{transform:scale(.95)}
  .mobileControls{position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:space-between;z-index:45;pointer-events:none}
  .circle{width:64px;height:64px;border-radius:50%;border:2px solid rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center;background:transparent;pointer-events:auto}
  .fireBtn{width:76px;height:76px;border-radius:14px;border:2px solid var(--accent);font-weight:800;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));pointer-events:auto}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:60;pointer-events:none}
  .menu{width:min(720px,92%);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:20px;border-radius:14px;pointer-events:auto;text-align:center;border:2px solid rgba(255,255,255,0.04)}
  h1{margin:0 0 8px 0}
  .small{color:#cbd5e1;font-size:13px}
  @media(max-width:700px){ .circle{width:56px;height:56px}.fireBtn{width:64px;height:64px}.btn{padding:8px 10px;font-size:13px} }
</style>
</head>
<body>
<div class="wrap">
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="chip" id="scoreUI">Score: 0</div>
      <div class="chip" id="killsUI">Kills: 0</div>
      <div class="chip" id="powerUI">Bullet: 1</div>
    </div>

    <div class="controls">
      <button class="btn" id="autoBtn">Auto: OFF</button>
      <button class="btn" id="pauseBtn">Pause</button>
      <button class="btn secondary" id="muteBtn">Mute</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>

    <div class="mobileControls">
      <div style="pointer-events:auto;display:flex;gap:10px">
        <div class="circle" id="leftBtn">◀</div>
        <div class="circle" id="rightBtn">▶</div>
      </div>
      <div style="pointer-events:auto">
        <button class="fireBtn btn" id="fireBtn">FIRE</button>
      </div>
    </div>

    <div class="overlay" id="overlay" style="display:flex">
      <div class="menu" id="menuPanel">
        <h1>Galaxy Shooter</h1>
        <p class="small">Swipe anywhere to move in 2D (left/right/up/down). Auto-fire collects bullets automatically. Kill 50 small enemies to spawn the boss. Enemies may drop <strong>+</strong> pickups — collect to increase bullet size & damage.</p>
        <div style="margin-top:12px">
          <button class="btn" id="startBtn">Start Game</button>
          <button class="btn secondary" id="howBtn">How to Play</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* Galaxy Shooter — Implemented features:
   - Auto-fire toggle
   - 2D swipe/pointer drag movement (left/right/up/down)
   - After 50 small enemies killed => spawn a boss
   - Enemies may drop bullet pickups ('+') that increase bullet power & size
   - Single file, mobile-compatible
*/

/* ===== canvas setup ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth * 0.98;
let H = canvas.height = innerHeight * 0.98;
canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
const DPR = Math.min(devicePixelRatio || 1.5, 2);
canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
ctx.scale(DPR, DPR);

/* UI refs */
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
const autoBtn = document.getElementById('autoBtn');
const pauseBtn = document.getElementById('pauseBtn');
const muteBtn = document.getElementById('muteBtn');
const resetBtn = document.getElementById('resetBtn');
const fireBtn = document.getElementById('fireBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const scoreUI = document.getElementById('scoreUI');
const killsUI = document.getElementById('killsUI');
const powerUI = document.getElementById('powerUI');

/* state */
let running=false, paused=false, muted=false, autoFire=false;
let bullets = [], enemies = [], pickups = [], particles = [];
let player = null, boss = null;
let score = 0, enemiesKilled = 0, bossSpawned = false;
let spawnTimer = 0, spawnInterval = 900;
let lastTime = 0;
let autoFireInterval = null;

/* audio (tiny beeps) */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function beep(freq=700, dur=0.05){ if(muted) return; ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value = freq; g.gain.value = 0.06; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur); }

/* helpers */
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }
function roundRect(ctx,x,y,w,h,r){ const rad=r||6; ctx.beginPath(); ctx.moveTo(x+rad,y); ctx.arcTo(x+w,y,x+w,y+h,rad); ctx.arcTo(x+w,y+h,x,y+h,rad); ctx.arcTo(x,y+h,x,y,rad); ctx.arcTo(x,y,x+w,y,rad); ctx.closePath(); }

/* player factory */
function createPlayer(){
  return {
    x: W/2 - 24, y: H - 110, w:48, h:48,
    speed: 6, targetX: null, targetY: null,
    cooldown: 0, fireRate: 220,
    bulletPower: 1,   // increases when pickups collected (affects bullet size & damage)
    double:false,
    alive:true
  };
}

/* shoot: create bullet(s) using player's bulletPower */
function shoot(){
  if(!running || paused || !player.alive) return;
  const now = performance.now();
  if(player.cooldown && now - player.cooldown < player.fireRate) return;
  player.cooldown = now;
  const cx = player.x + player.w/2;
  // bullet size & damage scale with bulletPower
  const size = 6 + Math.min(player.bulletPower - 1, 6) * 3; // grows with power
  const dmg = 1 + Math.floor((player.bulletPower - 1)/2);
  if(player.double){
    bullets.push({x: cx - 12, y: player.y - 8, vy: -11, w:size, h:size*1.8, dmg});
    bullets.push({x: cx + 12, y: player.y - 8, vy: -11, w:size, h:size*1.8, dmg});
  } else {
    bullets.push({x: cx, y: player.y - 8, vy: -12, w:size, h:size*1.8, dmg});
  }
  beep(900,0.03);
}

/* spawn small enemy */
function spawnEnemy(){
  const e = {
    x: rand(24, W-72),
    y: -40,
    w:44, h:44,
    vy: 1.2 + Math.random()*0.9,
    hp: 1,
    type: 'small'
  };
  // 12% chance tougher enemy
  if(Math.random() < 0.12){ e.hp = 2; e.vy += 0.2; e.type = 'tough'; }
  enemies.push(e);
}

/* spawn boss (single big enemy) */
function spawnBoss(){
  boss = {
    x: W/2 - 140, y: -200, w:280, h:140,
    hp: 70 + 20 * Math.floor(enemiesKilled/50), maxHp: 70 + 20 * Math.floor(enemiesKilled/50),
    vy: 0.7, timer:0, phase:1
  };
  bossSpawned = true;
  beep(240,0.12);
}

/* when enemy dies, maybe drop a pickup */
function onEnemyDeath(e){
  enemiesKilled++;
  score += (e.type==='tough')? 3:1;
  // 30% chance to drop bullet pickup
  if(Math.random() < 0.30){
    pickups.push({
      x: e.x + e.w/2, y: e.y + e.h/2,
      vy: 1.2, w:18, h:18, kind:'bullet'  // bullet pickup increases bulletPower
    });
  }
  // also spawn small explosion particles
  for(let i=0;i<10;i++){
    particles.push({x:e.x + e.w/2, y:e.y + e.h/2, vx:rand(-2.5,2.5), vy:rand(-4,1), life:rand(30,60), size:rand(1,3), col:'#ff9b9b'});
  }
  beep(1200,0.03);
}

/* pickup collected */
function collectPickup(p){
  if(p.kind === 'bullet'){
    player.bulletPower = Math.min(12, player.bulletPower + 1); // cap
    powerUI.innerText = 'Bullet: ' + player.bulletPower;
    // small feedback
    for(let i=0;i<6;i++) particles.push({x:p.x, y:p.y, vx:rand(-1.8,1.8), vy:rand(-3,0), life:rand(20,50), size:rand(1,3), col:'#9fffb6'});
    beep(1400,0.06);
  }
}

/* collision helpers */
function hitRectPoint(rx,ry,rw,rh,px,py){ return px >= rx && px <= rx+rw && py >= ry && py <= ry+rh; }
function rectColl(a,b){ 
  const aw = a.w||6, ah = a.h||10;
  const ax = a.x - aw/2, ay = a.y - ah/2;
  return !(ax + aw < b.x || ax > b.x + b.w || ay + ah < b.y || ay > b.y + b.h);
}

/* pointer drag for 2D movement */
let pointerDown=false;
function onPointerDown(e){
  pointerDown = true;
  const p = getPointerPos(e);
  if(!p) return;
  player.targetX = clamp(p.x - player.w/2, 8, W - player.w - 8);
  player.targetY = clamp(p.y - player.h/2, 8, H - player.h - 8);
}
function onPointerMove(e){
  if(!pointerDown) return;
  const p = getPointerPos(e);
  if(!p) return;
  player.targetX = clamp(p.x - player.w/2, 8, W - player.w - 8);
  player.targetY = clamp(p.y - player.h/2, 8, H - player.h - 8);
}
function onPointerUp(e){ pointerDown = false; }
function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  let clientX = e.clientX, clientY = e.clientY;
  if(e.touches && e.touches[0]){ clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
  if(clientX == null) return null;
  const x = (clientX - rect.left) / rect.width * W;
  const y = (clientY - rect.top) / rect.height * H;
  return {x,y};
}

/* keyboard & buttons */
let keys = {};
addEventListener('keydown', ev => { keys[ev.code]=true; if(ev.code==='Space') shoot(); if(ev.code==='KeyP') togglePause(); });
addEventListener('keyup', ev => { keys[ev.code]=false; });
leftBtn.addEventListener('touchstart', e=>{ e.preventDefault(); keys['ArrowLeft'] = true; });
leftBtn.addEventListener('touchend', e=>{ e.preventDefault(); keys['ArrowLeft'] = false; });
rightBtn.addEventListener('touchstart', e=>{ e.preventDefault(); keys['ArrowRight'] = true; });
rightBtn.addEventListener('touchend', e=>{ e.preventDefault(); keys['ArrowRight'] = false; });
leftBtn.addEventListener('mousedown', ()=> keys['ArrowLeft']=true); document.addEventListener('mouseup', ()=> keys['ArrowLeft']=false);
rightBtn.addEventListener('mousedown', ()=> keys['ArrowRight']=true); document.addEventListener('mouseup', ()=> keys['ArrowRight']=false);

canvas.addEventListener('touchstart', onPointerDown, {passive:false});
canvas.addEventListener('touchmove', onPointerMove, {passive:false});
canvas.addEventListener('touchend', onPointerUp, {passive:false});
canvas.addEventListener('pointerdown', onPointerDown);
canvas.addEventListener('pointermove', onPointerMove);
canvas.addEventListener('pointerup', onPointerUp);

/* UI button hooks */
startBtn.addEventListener('click', startGame);
howBtn.addEventListener('click', ()=> alert('Swipe anywhere to move in 2D. Auto toggles continuous fire. Collect + pickups to increase bullet size/damage. Kill 50 small enemies to spawn the boss.'));
fireBtn.addEventListener('click', shoot);
autoBtn.addEventListener('click', ()=> { autoFire = !autoFire; autoBtn.innerText = 'Auto: ' + (autoFire? 'ON':'OFF'); setupAutoFire(); });
pauseBtn.addEventListener('click', togglePause);
muteBtn.addEventListener('click', ()=> { muted = !muted; muteBtn.innerText = muted? 'Unmute':'Mute'; });
resetBtn.addEventListener('click', ()=> location.reload());

/* auto-fire management */
function setupAutoFire(){
  if(autoFireInterval) { clearInterval(autoFireInterval); autoFireInterval = null; }
  if(!autoFire) return;
  const period = Math.max(60, Math.round(player.fireRate * 0.9));
  autoFireInterval = setInterval(()=> { if(running && !paused && player.alive) shoot(); }, period);
}

/* game loop */
function startGame(){
  bullets = []; enemies = []; pickups = []; particles = []; boss = null;
  player = createPlayer(); score = 0; enemiesKilled = 0; bossSpawned = false; spawnTimer = 0; spawnInterval = 900; running = true; paused = false;
  overlay.style.display = 'none';
  scoreUI.innerText = 'Score: 0'; killsUI.innerText = 'Kills: 0'; powerUI.innerText = 'Bullet: 1';
  setupAutoFire();
  requestAnimationFrame(loop);
}
function togglePause(){ if(!running) return; paused = !paused; pauseBtn.innerText = paused? 'Resume':'Pause'; if(paused) { if(autoFireInterval) clearInterval(autoFireInterval); } else setupAutoFire(); if(!paused) requestAnimationFrame(loop); }
function endGame(){ running = false; overlay.style.display = 'flex'; document.getElementById('menuPanel').querySelector('h1').innerText = 'Game Over'; }

/* spawn logic and update */
function update(dt){
  if(!running || paused) return;

  // player smooth follow to target (from swipe) OR keyboard control
  if(player.targetX !== null && player.targetY !== null){
    player.x += (player.targetX - player.x) * 0.24;
    player.y += (player.targetY - player.y) * 0.24;
  } else {
    if(keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
    if(keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
    if(keys['ArrowUp'] || keys['KeyW']) player.y -= player.speed;
    if(keys['ArrowDown'] || keys['KeyS']) player.y += player.speed;
  }
  player.x = clamp(player.x, 8, W - player.w - 8);
  player.y = clamp(player.y, 8, H - player.h - 8);

  // spawn small enemies until boss threshold
  spawnTimer += dt;
  if(!boss && spawnTimer > spawnInterval){
    spawnTimer = 0;
    spawnEnemy();
    // minor vary spawn interval
    spawnInterval = Math.max(400, 900 - Math.floor(enemiesKilled/10)*20);
  }

  // spawn boss when killed 50 small enemies and not already spawned
  if(!bossSpawned && enemiesKilled >= 50){
    spawnBoss();
  }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y += b.vy;
    if(b.y < -40) bullets.splice(i,1);
  }

  // update enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.vy;
    // simple dodge behavior: move slightly away from nearest bullet
    for(let b of bullets){
      if(b.vy >= 0) continue;
      const d = dist(b.x,b.y, e.x + e.w/2, e.y + e.h/2);
      if(d < 70 && Math.random() < 0.5) e.x += (Math.random() < 0.5 ? -1 : 1) * 6;
    }
    // collisions with player bullets
    for(let bi = bullets.length-1; bi >= 0; bi--){
      const b = bullets[bi];
      if(b.vy >= 0) continue;
      if(rectColl(b, e)){
        e.hp -= b.dmg || 1;
        bullets.splice(bi,1);
        if(e.hp <= 0){
          onEnemyDeath(e);
          enemies.splice(i,1);
        }
        break;
      }
    }
    // if enemy goes past bottom remove
    if(e.y > H + 60) enemies.splice(i,1);
  }

  // boss update (single boss)
  if(boss){
    boss.timer += dt;
    boss.y += boss.vy;
    boss.x += Math.sin(boss.timer/800) * 1.5;
    boss.x = clamp(boss.x, 20, W - boss.w - 20);
    // boss attack pattern: if above screen small gun that shoots downward every interval
    if(boss.timer > 900){
      boss.timer = 0;
      // drop 3 hostile bullets
      for(let k=-1;k<=1;k++){
        bullets.push({x: boss.x + boss.w/2 + k*24, y: boss.y + boss.h, vy: 4.2, w:8, h:12, dmg:-1, hostile:true});
      }
      beep(320,0.06);
    }
    // boss hit by player bullets
    for(let bi = bullets.length-1; bi >= 0; bi--){
      const b = bullets[bi];
      if(b.vy >= 0) continue;
      if(rectColl(b, boss)){
        boss.hp -= b.dmg || 1;
        bullets.splice(bi,1);
        if(boss.hp <= 0){
          // boss destroyed: big score and reset counters
          for(let i=0;i<60;i++) particles.push({x:boss.x + boss.w/2, y: boss.y + boss.h/2, vx:rand(-5,5), vy:rand(-6,2), life:rand(40,90), size:rand(2,5), col:'#ffd27e'});
          score += 200;
          boss = null;
          enemiesKilled = 0; // reset kill count if you want repeated bosses
          bossSpawned = false;
        }
        break;
      }
    }
  }

  // hostile bullets hitting player
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(!b.hostile) continue;
    if(rectColl(b, player)){
      bullets.splice(i,1);
      // player damage logic; for simplicity, end game on hit
      // you can add lives instead
      player.alive = false;
      endGame();
      break;
    }
  }

  // pickups movement & collection
  for(let i=pickups.length-1;i>=0;i--){
    const p = pickups[i];
    p.y += p.vy;
    if(hitRectPoint(p.x - p.w/2, p.y - p.h/2, p.w, p.h, player.x + player.w/2, player.y + player.h/2)){
      collectPickup(p);
      pickups.splice(i,1);
      continue;
    }
    if(p.y > H + 40) pickups.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const pt = particles[i];
    pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.12; pt.life -= 1;
    if(pt.life <= 0) particles.splice(i,1);
  }

  // score/kills UI
  scoreUI.innerText = 'Score: ' + score;
  killsUI.innerText = 'Kills: ' + enemiesKilled;
}

/* draw */
function draw(){
  // background
  ctx.clearRect(0,0,W,H);
  // simple star field
  ctx.fillStyle = '#000814';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#ffffff';
  for(let i=0;i<50;i++){
    const x = (i*53 + performance.now()/20*(i%4+1)) % W;
    const y = ((i*31) + performance.now()/200*(i%3+1)) % H;
    ctx.globalAlpha = 0.7 - (i%5)*0.12;
    ctx.fillRect(x,y,2,2);
  }
  ctx.globalAlpha = 1;

  // player
  if(player && player.alive){
    drawPlayer(player);
  }

  // bullets
  for(let b of bullets){
    if(b.hostile){
      ctx.fillStyle = '#ff8b8b';
      roundRect(ctx, b.x - (b.w||6)/2, b.y - (b.h||10)/2, b.w||6, b.h||10, 4);
      ctx.fill();
    } else {
      ctx.fillStyle = '#aefcff';
      roundRect(ctx, b.x - (b.w||6)/2, b.y - (b.h||12)/2, b.w||6, b.h||12, 4);
      ctx.fill();
    }
  }

  // enemies
  for(let e of enemies){
    ctx.save();
    ctx.fillStyle = e.type === 'tough' ? '#ffd38a' : '#ff8b7f';
    roundRect(ctx, e.x, e.y, e.w, e.h, 8); ctx.fill();
    ctx.fillStyle = '#001';
    ctx.fillRect(e.x + e.w/2 - 8, e.y + e.h/2 - 6, 16, 12);
    ctx.restore();
  }

  // pickups
  for(let p of pickups){
    ctx.save();
    ctx.fillStyle = '#9fffb6';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.w/2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#003'; ctx.font = '14px bold sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle'; ctx.fillText('+', p.x, p.y);
    ctx.restore();
  }

  // boss
  if(boss){
    ctx.save();
    const grad = ctx.createLinearGradient(boss.x, boss.y, boss.x + boss.w, boss.y + boss.h);
    grad.addColorStop(0, '#ffdfb6'); grad.addColorStop(1, '#ffb07f');
    ctx.fillStyle = grad; roundRect(ctx, boss.x, boss.y, boss.w, boss.h, 12); ctx.fill();
    // HP bar
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; roundRect(ctx, boss.x + 20, boss.y + boss.h + 8, boss.w - 40, 10, 6); ctx.fill();
    ctx.fillStyle = '#7ef9ff'; const hpPct = clamp(boss.hp / boss.maxHp, 0, 1);
    roundRect(ctx, boss.x + 20, boss.y + boss.h + 8, (boss.w - 40) * hpPct, 10, 6); ctx.fill();
    ctx.restore();
  }

  // particles
  for(let pt of particles){
    ctx.fillStyle = pt.col || '#fff'; ctx.globalAlpha = clamp(pt.life/80,0,1); ctx.fillRect(pt.x, pt.y, pt.size, pt.size); ctx.globalAlpha = 1;
  }
}

/* draw player ship */
function drawPlayer(p){
  ctx.save();
  ctx.translate(p.x + p.w/2, p.y + p.h/2);
  ctx.rotate(Math.sin(performance.now()/240)/18);
  ctx.fillStyle = '#bfefff';
  ctx.beginPath(); ctx.moveTo(-p.w/2 + 8, p.h/2 - 6); ctx.lineTo(0, -p.h/2); ctx.lineTo(p.w/2 - 8, p.h/2 - 6); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#002'; ctx.beginPath(); ctx.ellipse(0, -4, 8, 6, 0, 0, Math.PI*2); ctx.fill();
  // show bullet power visually near ship
  ctx.fillStyle = '#fff'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('P:' + player.bulletPower, 0, p.h/2 + 14);
  ctx.restore();
}

/* main animation loop */
function loop(ts){
  if(!running || paused) return;
  if(!lastTime) lastTime = ts;
  const dt = Math.min(40, ts - lastTime);
  lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* helpers continued */
function spawnWave(count=1){
  for(let i=0;i<count;i++) spawnEnemy();
}

/* Start/stop autoFire interval */
function setupAutoInterval(){
  if(autoFireInterval) { clearInterval(autoFireInterval); autoFireInterval = null; }
  if(autoFire){
    const period = Math.max(60, Math.round(player.fireRate * 0.9));
    autoFireInterval = setInterval(()=> { if(running && !paused && player.alive) shoot(); }, period);
  }
}
let autoFireInterval = null;

/* start game */
function initSizes(){
  W = canvas.style.width = innerWidth * 0.98;
  H = canvas.style.height = innerHeight * 0.98;
  canvas.width = Math.floor(W * DPR); canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', initSizes);
initSizes();

function startGame(){
  bullets = []; enemies = []; pickups = []; particles = []; boss = null;
  player = createPlayer();
  score = 0; enemiesKilled = 0; bossSpawned = false; spawnTimer = 0; spawnInterval = 900;
  running = true; paused = false;
  overlay.style.display = 'none';
  setupAutoInterval();
  requestAnimationFrame(loop);
}

/* toggles */
function togglePause(){ if(!running) return; paused = !paused; pauseBtn.innerText = paused? 'Resume':'Pause'; if(paused) { if(autoFireInterval) clearInterval(autoFireInterval); } else setupAutoInterval(); if(!paused) requestAnimationFrame(loop); }

/* end game */
function endGame(){ running = false; overlay.style.display = 'flex'; document.getElementById('menuPanel').querySelector('h1').innerText = 'Game Over'; if(autoFireInterval) { clearInterval(autoFireInterval); autoFireInterval=null; } }

/* ensure audio unlock on first touch/mousedown */
document.addEventListener('touchstart', ()=> { ensureAudio(); }, {once:true});
document.addEventListener('mousedown', ()=> { ensureAudio(); }, {once:true});

/* quick double-click to start */
document.addEventListener('dblclick', ()=> { if(!running) startGame(); });

/* initial overlay */
overlay.style.display = 'flex';

/* expose start button */
startBtn.addEventListener('click', startGame);

</script>
</body>
</html>
