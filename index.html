<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Shooter — Full Updated</title>
<style>
  :root{
    --accent: #7ef9ff;
    --accent2: #b388ff;
    --glass: rgba(255,255,255,0.06);
  }
  html,body{height:100%;margin:0;background:#000;font-family:Inter,system-ui,Arial;}
  .wrap{display:flex;flex-direction:column;height:100vh;width:100vw;align-items:center;justify-content:center;overflow:hidden;}
  /* Game area */
  #gameContainer{position:relative;width:100%;height:100%;max-width:1100px;background:linear-gradient(180deg,#030214 0%, #001028 100%);border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,0.6);}
  canvas{display:block;width:100%;height:100%;}
  /* UI overlay */
  .hud{position:absolute;left:12px;top:12px;color:#fff;z-index:30;display:flex;gap:12px;align-items:center}
  .scoreBox{backdrop-filter:blur(6px);background:var(--glass);padding:8px 14px;border-radius:10px;border:2px solid rgba(255,255,255,0.06);font-weight:600;}
  .lives{backdrop-filter:blur(6px);background:var(--glass);padding:8px 12px;border-radius:10px;border:2px solid rgba(255,255,255,0.06);display:flex;gap:8px;align-items:center;}
  .controlsTop{position:absolute;right:12px;top:12px;display:flex;gap:10px;z-index:30;}
  .btn{
    padding:10px 14px;border-radius:12px;border:2px solid var(--accent);background:transparent;color:var(--accent);font-weight:700;cursor:pointer;outline:none;
    transition:transform .12s ease, background .12s; box-shadow: 0 4px 18px rgba(0,0,0,0.6);
  }
  .btn:active{transform:scale(.95);background:rgba(126,249,255,0.06);}
  .btn.secondary{border-color:var(--accent2); color:var(--accent2);}
  /* bottom mobile controls */
  .mobileControls{position:absolute;left:12px;right:12px;bottom:14px;z-index:40;display:flex;justify-content:space-between;align-items:center;pointer-events:none;}
  .pad{display:flex;gap:10px;pointer-events:auto;}
  .circle{
    width:72px;height:72px;border-radius:50%;border:2px solid rgba(255,255,255,0.12);
    display:flex;align-items:center;justify-content:center;font-size:28px;color:#fff;background:transparent;
    backdrop-filter:blur(6px);transition:transform .08s; user-select:none;
  }
  .circle:active{transform:scale(.9);background:rgba(255,255,255,0.06)}
  .fireBtn{width:84px;height:84px;border-radius:18px;border:2px solid var(--accent);color:var(--accent);font-weight:800;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));pointer-events:auto;}
  /* overlay panels */
  .panel{position:absolute;z-index:50;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;}
  .menu{
    width:min(680px,92%);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:16px;padding:24px;
    border:2px solid rgba(255,255,255,0.04);backdrop-filter:blur(8px);text-align:center;color:#fff;pointer-events:auto;
  }
  h1{font-size:20px;margin-bottom:8px;letter-spacing:1px}
  p{opacity:.85;margin-bottom:12px}
  .small{font-size:13px;color:#cbd5e1}
  .stat{display:flex;gap:14px;justify-content:center;margin:12px 0}
  .stat div{background:rgba(255,255,255,0.03);padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
  /* progress bar */
  .barWrap{height:12px;background:rgba(255,255,255,0.03);border-radius:10px;overflow:hidden;margin-top:8px}
  .bar{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));width:0%}
  @media (max-width:700px){
    .hud{left:8px;top:8px;gap:8px}
    .btn{padding:8px 10px;font-size:13px}
    .circle{width:64px;height:64px}
    .fireBtn{width:72px;height:72px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div id="gameContainer">
    <canvas id="game"></canvas>

    <!-- HUD -->
    <div class="hud">
      <div class="scoreBox" id="scoreUI">Score: 0</div>
      <div class="lives" id="livesUI">Lives: ♥♥♥</div>
      <div class="scoreBox" id="levelUI">Level: 1</div>
    </div>

    <div class="controlsTop">
      <button class="btn" id="pauseBtn">Pause</button>
      <button class="btn secondary" id="muteBtn">Mute</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>

    <!-- Mobile controls -->
    <div class="mobileControls">
      <div class="pad" id="leftPad" style="pointer-events:auto">
        <div class="circle" id="leftBtn">◀</div>
        <div class="circle" id="rightBtn">▶</div>
      </div>
      <div style="pointer-events:auto">
        <button class="fireBtn btn" id="fireBtn">FIRE</button>
      </div>
    </div>

    <!-- Menu / Game Over Panel -->
    <div id="overlay" class="panel">
      <div class="menu" id="menuPanel">
        <h1>Galaxy Shooter</h1>
        <p class="small">Use arrow keys / touch controls to move. Space or FIRE to shoot. Survive waves and beat bosses.</p>
        <div class="stat">
          <div>High Score<br><strong id="highScore">0</strong></div>
          <div>Last Score<br><strong id="lastScore">0</strong></div>
        </div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:8px">
          <button class="btn" id="startBtn">Start Game</button>
          <button class="btn secondary" id="howBtn">How to Play</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* ====== Constants & Setup ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { antialias: true });
let W = canvas.width = innerWidth * 0.98;
let H = canvas.height = innerHeight * 0.98;
const DPR = Math.min(devicePixelRatio || 1.5, 2);
canvas.width = Math.floor(W * DPR);
canvas.height = Math.floor(H * DPR);
canvas.style.width = W + 'px';
canvas.style.height = H + 'px';
ctx.scale(DPR, DPR);

/* UI elements */
const overlay = document.getElementById('overlay');
const menuPanel = document.getElementById('menuPanel');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
const pauseBtn = document.getElementById('pauseBtn');
const muteBtn = document.getElementById('muteBtn');
const resetBtn = document.getElementById('resetBtn');
const fireBtn = document.getElementById('fireBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const scoreUI = document.getElementById('scoreUI');
const livesUI = document.getElementById('livesUI');
const levelUI = document.getElementById('levelUI');
const highScoreEl = document.getElementById('highScore');
const lastScoreEl = document.getElementById('lastScore');

/* Game state */
let running = false, paused = false, muted = false;
let score = 0, highScore = localStorage.getItem('gs_high') || 0, lastScore = localStorage.getItem('gs_last') || 0;
highScoreEl.innerText = highScore;
lastScoreEl.innerText = lastScore;
let level = 1, lives = 3;
let bullets = [], enemies = [], particles = [], powerups = [];
let keys = {};
let player = null;
let spawnTimer = 0, spawnRate = 1000;
let boss = null;
let shake = 0;

/* Audio: simple WebAudio synth for SFX */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new AudioCtx();
}
function playTone(freq = 200, type='sine', time=0.05, gain=0.08){
  if(muted) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + time);
}
function playExplosion(){
  if(muted) return;
  ensureAudio();
  const now = audioCtx.currentTime;
  const b = audioCtx.createBufferSource();
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for(let i=0;i<data.length;i++){
    data[i] = (Math.random()*2-1) * Math.exp(-3*i/data.length);
  }
  b.buffer = buf; b.connect(audioCtx.destination); b.start(now);
}

/* ====== Utility ====== */
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }

/* ====== Entities ====== */
/* Player */
function createPlayer(){
  return {
    x: W/2, y: H - 90, w: 56, h: 56,
    speed: 6, cooldown:0, fireRate: 220, double:false, shield:0, alive:true
  };
}

/* Enemy prototype */
function spawnEnemy(type='normal'){
  const e = {
    x: rand(30, W-60),
    y: -60,
    w: 48, h: 48,
    vx: 0, vy: 1.2 + level*0.35 + Math.random()*0.8,
    hp: type==='boss'? 15 + level*8 : (type==='tough'? 3+level:1),
    type,
    angle: 0,
    shootTimer: 0
  };
  enemies.push(e);
  return e;
}

/* Powerup spawn */
function spawnPowerup(x,y){
  const types = ['rapid','double','shield','life'];
  powerups.push({
    x,y,w:28,h:28,type: types[Math.floor(Math.random() * types.length)],
    vy:1.2
  });
}

/* Particle (explosion) */
function spawnExplosion(x,y,count=18,color='#fff'){
  for(let i=0;i<count;i++){
    particles.push({
      x,y,
      vx: rand(-3,3), vy: rand(-4,2),
      life: rand(30,70), size: rand(1,4),
      color,
    });
  }
  playExplosion();
  shake = 6;
}

/* Boss creation */
function spawnBoss(){
  boss = {
    x: W/2 - 120, y: -180, w: 240, h: 140,
    vx: 1.2, vy: 0.6, hp: 30 + level*20, maxHp:30 + level*20, phase:0, timer:0
  };
}

/* ====== Input ====== */
addEventListener('keydown', e => { keys[e.code] = true; if(e.code==='Space') shoot(); if(e.code==='KeyP') togglePause(); });
addEventListener('keyup', e => { keys[e.code] = false; });
startBtn.onclick = ()=> startGame();
howBtn.onclick = ()=> alert("Move: Arrow keys / touch ◀ ▶\nShoot: Space / FIRE\nCollect power-ups: Rapid, Double, Shield, Extra Life.\nBeat bosses to progress levels.");
pauseBtn.onclick = ()=> togglePause();
muteBtn.onclick = ()=> { muted = !muted; muteBtn.innerText = muted? 'Unmute':'Mute'; }
resetBtn.onclick = ()=> { localStorage.removeItem('gs_high'); localStorage.removeItem('gs_last'); highScore=0; highScoreEl.innerText=0; lastScoreEl.innerText=0; alert('Scores reset.'); }
fireBtn.onclick = ()=> shoot();
leftBtn.addEventListener('touchstart', e=>{e.preventDefault(); keys['ArrowLeft']=true;}); leftBtn.addEventListener('touchend', e=>{e.preventDefault(); keys['ArrowLeft']=false;});
rightBtn.addEventListener('touchstart', e=>{e.preventDefault(); keys['ArrowRight']=true;}); rightBtn.addEventListener('touchend', e=>{e.preventDefault(); keys['ArrowRight']=false;});
document.getElementById('leftBtn').addEventListener('mousedown', ()=> keys['ArrowLeft']=true); document.addEventListener('mouseup', ()=> keys['ArrowLeft']=false);
document.getElementById('rightBtn').addEventListener('mousedown', ()=> keys['ArrowRight']=true); document.addEventListener('mouseup', ()=> keys['ArrowRight']=false);

/* Shoot function */
function shoot(){
  if(!running || paused || !player.alive) return;
  const now = performance.now();
  if(player.cooldown && now - player.cooldown < player.fireRate) return;
  player.cooldown = now;
  // bullets: simple objects
  const bx = player.x + player.w/2, by = player.y - 6;
  if(player.double){
    bullets.push({x: bx - 12, y: by, vy:-9, w:6,h:12, dmg:1});
    bullets.push({x: bx + 12, y: by, vy:-9, w:6,h:12, dmg:1});
  } else {
    bullets.push({x: bx, y: by, vy:-10, w:6,h:12, dmg:1});
  }
  if(player.fireRate < 240) playTone(900, 'square', 0.06, 0.04);
  else playTone(650, 'sine', 0.04, 0.06);
}

/* ====== Game Loop ====== */
function startGame(){
  // reset
  score = 0; level = 1; lives = 3; spawnRate = 1000; enemies=[]; bullets=[]; particles=[]; powerups=[]; boss=null;
  player = createPlayer(); player.double=false; player.fireRate = 220;
  running = true; paused = false; overlay.style.display='none';
  scoreUI.innerText = 'Score: 0'; livesUI.innerText = 'Lives: ' + '♥'.repeat(lives); levelUI.innerText = 'Level: 1';
  playTone(1200,'sine',0.08,0.06);
  lastScoreEl.innerText = lastScore;
  loop();
}

function endGame(){
  running = false;
  overlay.style.display = 'flex';
  menuPanel.querySelector('h1').innerText = 'Game Over';
  menuPanel.querySelector('.small').innerText = 'Nice try, pilot. Play again to beat your high score.';
  document.getElementById('highScore').innerText = highScore;
  localStorage.setItem('gs_last', score);
  localStorage.setItem('gs_high', highScore);
  lastScoreEl.innerText = score;
  playTone(120,'sawtooth',0.12,0.08);
}

/* Pause toggle */
function togglePause(){
  if(!running) return;
  paused = !paused;
  pauseBtn.innerText = paused ? 'Resume':'Pause';
  if(!paused) loop();
}

/* Resize handler */
addEventListener('resize', ()=>{
  W = canvas.style.width = innerWidth * 0.98;
  H = canvas.style.height = innerHeight * 0.98;
  canvas.width = Math.floor(innerWidth * 0.98 * DPR);
  canvas.height = Math.floor(innerHeight * 0.98 * DPR);
  canvas.style.width = innerWidth * 0.98 + 'px';
  canvas.style.height = innerHeight * 0.98 + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
});

/* Main loop */
let lastTime = 0;
function loop(ts){
  if(!running) return;
  if(paused){ lastTime = ts || performance.now(); return; }
  const dt = Math.min(40, (ts - lastTime) || 16);
  lastTime = ts || performance.now();

  update(dt);
  draw();

  if(running) requestAnimationFrame(loop);
}

/* ====== Update ====== */
function update(dt){
  // player movement
  if(keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
  if(keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
  player.x = clamp(player.x, 14, W - player.w - 14);

  // spawn enemies
  spawnTimer += dt;
  const effectiveSpawn = Math.max(520 - level*30, 220);
  if(!boss && spawnTimer > (spawnRate - level*40)){
    spawnTimer = 0;
    const t = Math.random();
    if(Math.random() < 0.06 && score > 6) spawnEnemy('tough');
    else spawnEnemy('normal');
    // occasional powerup
    if(Math.random() < 0.06) spawnPowerup(rand(60,W-60), -20);
  }

  // escalate: spawn boss per certain score threshold
  if(!boss && score >= level * 20){
    spawnBoss();
  }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y += b.vy;
    if(b.y < -20 || b.y > H+20) bullets.splice(i,1);
  }

  // update enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    e.y += e.vy;
    e.x += Math.sin((e.y+e.x)/120) * 0.8;
    // enemy shoot occasionally
    e.shootTimer += dt;
    if(e.shootTimer > 1600 && Math.random()<0.4){
      e.shootTimer = 0;
      // enemy bullet -> we implement as small harmful particles
      bullets.push({x: e.x + e.w/2, y: e.y + e.h + 10, vy: 4, w:6,h:10, dmg: -1, hostile:true});
    }
    if(e.y > H + 60) enemies.splice(i,1);
  }

  // boss behavior
  if(boss){
    boss.timer += dt;
    boss.y += boss.vy;
    boss.x += Math.sin(boss.timer/600) * boss.vx;
    boss.x = clamp(boss.x, 20, W - boss.w - 20);
    // boss shoot pattern
    if(boss.timer > 800){
      boss.timer = 0;
      // fire bullets downwards
      for(let k=-2;k<=2;k++){
        bullets.push({x: boss.x + boss.w/2 + k*14, y: boss.y + boss.h/1.2, vy: 4.2, w:6,h:10, dmg:-1, hostile:true});
      }
      playTone(260,'sawtooth',0.06,0.06);
    }
    if(boss.y > 80) boss.vy = 0;
    if(boss.hp <= 0){
      spawnExplosion(boss.x + boss.w/2, boss.y + boss.h/2, 60, '#ffcc66');
      score += 12 + level*6;
      boss = null;
      level++;
      spawnRate = Math.max(420 - level*18, 300);
      playTone(1100,'sine',0.12,0.08);
    }
  }

  // bullets vs enemies & boss
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(b.hostile) continue; // don't collide player bullets with hostile bullets
    // enemy collision
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(rectColl(b,e)){
        e.hp -= b.dmg;
        bullets.splice(i,1);
        spawnExplosion(e.x + e.w/2, e.y + e.h/2, 8, '#ff7f7f');
        playTone(1400,'triangle',0.03,0.03);
        if(e.hp <= 0){
          score += 1 + level;
          enemies.splice(j,1);
        }
        break;
      }
    }
    if(!bullets[i]) continue;
    // boss collision
    if(boss && rectColl(b,boss)){
      boss.hp -= b.dmg;
      bullets.splice(i,1);
      spawnExplosion(b.x, b.y, 8, '#ffd1a6');
      if(boss.hp <= 0){ /* handled above */ }
    }
  }

  // hostile bullets vs player
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(!b.hostile) continue;
    if(rectColl(b, player)){
      bullets.splice(i,1);
      if(player.shield > 0) {
        player.shield -= 1;
        spawnExplosion(player.x + player.w/2, player.y + player.h/2, 6, '#aaffff');
        playTone(400,'sine',0.05,0.04);
      } else {
        // lose life
        lives -= 1;
        spawnExplosion(player.x + player.w/2, player.y + player.h/2, 18, '#ff6666');
        playTone(140,'sawtooth',0.12,0.08);
        if(lives <= 0){
          player.alive=false;
          // slight delay then end
          setTimeout(()=> endGame(), 600);
        }
      }
      livesUI.innerText = 'Lives: ' + '♥'.repeat(Math.max(0,lives));
    }
  }

  // enemies vs player collision
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(rectColl(e, player)){
      enemies.splice(i,1);
      if(player.shield > 0){ player.shield -= 1; spawnExplosion(player.x + player.w/2, player.y + player.h/2, 10, '#aaffff'); }
      else { lives -= 1; spawnExplosion(player.x + player.w/2, player.y + player.h/2, 20, '#ff6666'); }
      livesUI.innerText = 'Lives: ' + '♥'.repeat(Math.max(0,lives));
      if(lives <= 0){ player.alive = false; setTimeout(()=> endGame(), 600); }
    }
  }

  // powerups
  for(let i=powerups.length-1;i>=0;i--){
    const p = powerups[i];
    p.y += p.vy;
    if(rectColl(p, player)){
      // apply
      if(p.type==='rapid'){ player.fireRate = Math.max(90, player.fireRate - 120); setTimeout(()=> player.fireRate = 220, 9000); }
      if(p.type==='double'){ player.double = true; setTimeout(()=> player.double = false, 9000); }
      if(p.type==='shield'){ player.shield = (player.shield || 0) + 2; setTimeout(()=> player.shield = Math.max(0, player.shield-2), 12000); }
      if(p.type==='life'){ lives = Math.min(5, lives + 1); livesUI.innerText = 'Lives: ' + '♥'.repeat(lives); }
      playTone(1200,'triangle',0.08,0.06);
      powerups.splice(i,1);
      continue;
    }
    if(p.y > H + 30) powerups.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const pt = particles[i];
    pt.x += pt.vx; pt.y += pt.vy;
    pt.vy += 0.12; pt.life -= 1;
    if(pt.life <= 0) particles.splice(i,1);
  }

  // update UI & score
  scoreUI.innerText = 'Score: ' + score;
  levelUI.innerText = 'Level: ' + level;
  if(score > highScore){ highScore = score; highScoreEl.innerText = highScore; localStorage.setItem('gs_high', highScore); }

  // reduce shake
  shake = Math.max(0, shake - 0.4);
}

/* ====== Draw ====== */
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // parallax starfield background (simple)
  drawBackground();

  // apply shake transform
  ctx.save();
  if(shake > 0){
    const sx = rand(-shake, shake), sy = rand(-shake, shake);
    ctx.translate(sx, sy);
  }

  // draw player
  if(player.alive){
    drawShip(player.x, player.y, player.w, player.h, player.shield);
  }

  // bullets
  for(let b of bullets){
    if(b.hostile) ctx.fillStyle = '#ff8b8b';
    else ctx.fillStyle = '#aefcff';
    roundRect(ctx, b.x - b.w/2, b.y - b.h/2, b.w, b.h, 3);
    ctx.fill();
  }

  // enemies
  for(let e of enemies){
    drawEnemy(e.x, e.y, e.w, e.h, e.hp);
  }

  // boss
  if(boss){
    drawBoss(boss);
  }

  // powerups
  for(let p of powerups){
    ctx.save();
    ctx.fillStyle = p.type==='rapid'? '#7ef9ff' : p.type==='double'? '#b388ff' : p.type==='shield'? '#9fffb6' : '#ffd27e';
    ctx.beginPath();
    ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#001';
    ctx.font = '12px bold sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.type[0].toUpperCase(), p.x, p.y);
    ctx.restore();
  }

  // particles
  for(let pt of particles){
    ctx.fillStyle = pt.color; ctx.globalAlpha = clamp(pt.life/80,0,1);
    roundRect(ctx, pt.x, pt.y, pt.size, pt.size, 2); ctx.fill(); ctx.globalAlpha = 1;
  }

  ctx.restore(); // restore from shake

  // HUD overlay effects (player shield)
  if(player.shield > 0){
    ctx.save();
    ctx.strokeStyle = 'rgba(160,255,240,0.12)'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.ellipse(player.x + player.w/2, player.y + player.h/2, 44, 30, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

/* Draw helpers */
function drawBackground(){
  // layered stars
  ctx.fillStyle = '#000814';
  ctx.fillRect(0,0,W,H);
  // moving stars
  const t = performance.now() / 60;
  ctx.fillStyle = '#ffffff';
  for(let i=0;i<60;i++){
    const x = (i*47 + t*0.6*(i%3+1)) % W;
    const y = ((i*31) + t*0.2*(i%4+1)) % H;
    ctx.globalAlpha = 0.85 - (i%5)*0.1;
    ctx.fillRect(x, y, 2, 2);
  }
  ctx.globalAlpha = 1;
  // faint nebula band
  const g = ctx.createLinearGradient(0, H*0.2, W, H*0.8);
  g.addColorStop(0, 'rgba(40,10,60,0.06)');
  g.addColorStop(0.5, 'rgba(90,10,150,0.08)');
  g.addColorStop(1, 'rgba(10,20,70,0.06)');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
}

function drawShip(x,y,w,h,shield){
  // ship body
  ctx.save();
  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(Math.sin(performance.now()/220)/18);
  // body
  ctx.fillStyle = '#bfefff';
  ctx.beginPath();
  ctx.moveTo(-w/2+8, h/2-6);
  ctx.lineTo(0, -h/2);
  ctx.lineTo(w/2-8, h/2-6);
  ctx.closePath();
  ctx.fill();
  // cockpit
  ctx.fillStyle = '#002';
  ctx.beginPath(); ctx.ellipse(0, -4, 8, 6, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawEnemy(x,y,w,h,hp){
  ctx.save();
  // pulsing color by hp
  const pct = clamp(hp/4,0,1);
  ctx.fillStyle = `rgba(${200 + pct*40}, ${130 + (1-pct)*80}, ${180 - pct*80}, 1)`;
  roundRect(ctx, x, y, w, h, 8);
  ctx.fill();
  // small eyes/cockpit
  ctx.fillStyle = '#001';
  ctx.fillRect(x + w/2 - 8, y + h/2 - 6, 16, 12);
  ctx.restore();
}

function drawBoss(b){
  ctx.save();
  // hull
  ctx.fillStyle = '#ffdb9b';
  roundRect(ctx, b.x, b.y, b.w, b.h, 14);
  ctx.fill();
  // eyes/guns
  ctx.fillStyle = '#3a1f1f';
  ctx.fillRect(b.x + 20, b.y + 30, 40, 12);
  ctx.fillRect(b.x + b.w - 60, b.y + 30, 40, 12);
  // HP bar
  const barW = b.w - 40;
  const hpPct = clamp(b.hp / b.maxHp, 0, 1);
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  roundRect(ctx, b.x + 20, b.y + b.h + 8, barW, 10, 6);
  ctx.fill();
  ctx.fillStyle = '#7ef9ff';
  roundRect(ctx, b.x + 20, b.y + b.h + 8, barW * hpPct, 10, 6);
  ctx.fill();
  ctx.restore();
}

/* Geometry */
function rectColl(a,b){
  return !(a.x - (a.w||0)/2 > b.x + b.w ||
           a.x + (a.w||0)/2 < b.x ||
           a.y - (a.h||0)/2 > b.y + b.h ||
           a.y + (a.h||0)/2 < b.y);
}

/* Round rect helper */
function roundRect(ctx,x,y,w,h,r){
  const radius = r || 6;
  ctx.beginPath();
  ctx.moveTo(x+radius,y);
  ctx.arcTo(x+w,y,x+w,y+h,radius);
  ctx.arcTo(x+w,y+h,x,y+h,radius);
  ctx.arcTo(x,y+h,x,y,radius);
  ctx.arcTo(x,y,x+w,y,radius);
  ctx.closePath();
}

/* ====== Init UI values ====== */
document.getElementById('highScore').innerText = highScore;
document.getElementById('lastScore').innerText = lastScore;

/* If overlay clicked start */
overlay.addEventListener('click', (e)=>{
  // click outside menu starts game quickly
  if(e.target === overlay) startGame();
});

/* Auto show menu on load */
overlay.style.display = 'flex';

/* Friendly tip: allow audio to be started on first interaction for mobile */
document.addEventListener('touchstart', ()=> { if(!audioCtx) ensureAudio(); }, { once:true });
document.addEventListener('mousedown', ()=> { if(!audioCtx) ensureAudio(); }, { once:true });

/* Offer initial cheat: quick start on double click */
document.addEventListener('dblclick', ()=> { if(!running) startGame(); });

</script>
</body>
</html>
