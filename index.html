<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Cut fruit ‚Äî Mobile Friendly</title>
<style>
  /* Basic reset */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:linear-gradient(180deg,#ffd1c1,#ff6f6f);font-family:Inter,system-ui,Arial,sans-serif;color:#111}
  /* App shell */
  .app {
    display:flex;
    flex-direction:column;
    height:100vh;
    overflow:hidden;
  }

  /* Top bar */
  header{
    height:56px;
    display:flex;
    align-items:center;
    gap:12px;
    padding:0 12px;
    background:rgba(0,0,0,0.85);
    color:#fff;
    box-shadow:0 2px 10px rgba(0,0,0,0.25);
    z-index:20;
  }
  .menu {
    width:36px;height:36px;border-radius:8px;border:2px solid rgba(255,255,255,0.12);
    display:flex;align-items:center;justify-content:center;
    cursor:pointer; backdrop-filter:blur(4px);
    transition:transform .18s ease;
  }
  .menu:active{transform:scale(.94)}
  .title{font-weight:600;font-size:18px}
  .top-right {
    margin-left:auto;display:flex;align-items:center;gap:10px;
  }
  /* outlined buttons */
  .btn {
    border-radius:10px;padding:8px 12px;border:2px solid rgba(255,255,255,0.85);
    background:transparent;color:#fff;font-weight:600;font-size:14px;
    display:inline-flex;align-items:center;gap:8px;cursor:pointer;
    transition:transform .18s ease, box-shadow .18s;
    position:relative;overflow:hidden;
  }
  .btn:active{transform:translateY(2px) scale(.98)}
  /* small ripple animation for click */
  .btn::after{
    content:"";position:absolute;width:0;height:0;border-radius:50%;background:rgba(255,255,255,0.12);
    transition:width .35s ease,height .35s ease,opacity .45s;opacity:0;
  }
  .btn:focus::after{opacity:1;width:200px;height:200px;left:-50px;top:-50px;}

  /* game area */
  .game-wrap{flex:1;position:relative;display:flex;align-items:stretch;justify-content:center;}
  canvas{
    display:block;
    width:100%;
    height:100%;
    touch-action:none; /* allow custom touch handling */
    background:linear-gradient(180deg, rgba(255,120,100,0.08), rgba(255,40,80,0.05));
  }

  /* overlay info */
  .hud{
    position:absolute;top:14px;left:50%;transform:translateX(-50%);z-index:18;
    display:flex;align-items:center;gap:10px;padding:6px 12px;border-radius:12px;
    background:rgba(255,255,255,0.92);box-shadow:0 6px 18px rgba(0,0,0,0.15);
    font-weight:700;color:#222;
  }
  .score {display:flex;align-items:center;gap:8px;font-size:18px}
  .time {font-size:14px;color:#666;font-weight:600}

  /* bottom controls for mobile */
  .controls{
    position:absolute;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:18;
  }

  /* small rounded pill for coin/time display */
  .pill{
    border-radius:999px;padding:6px 10px;border:2px solid rgba(0,0,0,0.06);background:rgba(255,255,255,0.95);
    font-weight:700;color:#222;display:inline-flex;align-items:center;gap:8px;
  }

  /* responsive text sizes */
  @media (max-width:420px){
    .title{font-size:16px}
    .hud{padding:4px 8px}
    .score{font-size:16px}
    .btn{padding:6px 10px;font-size:13px}
  }

  /* small fade in */
  .fade-in{animation:fadein .45s ease}
  @keyframes fadein{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="menu" id="menuBtn" title="Menu">
      ‚ò∞
    </div>
    <div class="title">Cut fruit</div>
    <div class="top-right">
      <div class="pill">‚è± <span id="timeLabel">60</span>s</div>
      <button class="btn" id="restartBtn">‚ôª Restart</button>
    </div>
  </header>

  <div class="game-wrap">
    <canvas id="game"></canvas>

    <div class="hud fade-in">
      <div class="score">üéØ Score: <span id="score">0</span></div>
      <div style="width:10px"></div>
      <div class="time">‚è≥ <span id="time">60</span>s</div>
    </div>

    <div class="controls">
      <button class="btn" id="pauseBtn">‚è∏ Pause</button>
      <button class="btn" id="shopBtn">üõí Shop</button>
    </div>
  </div>
</div>

<script>
/* ----------------------------
   Mobile-friendly Fruit Cut Game
   Hindi comments diye hue hain
   ---------------------------- */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.max(1, window.devicePixelRatio || 1);

// HUD
const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('time');
const timeLabel = document.getElementById('timeLabel');

let score = 0;
let gameTime = 60; // seconds
let paused = false;
let lastSpawn = 0;
let fruits = [];
let particles = [];
let mouseTrail = []; // for swipe line
let combos = 0;
let lastCutTime = 0;

// Canvas resize to fit container while preserving resolution
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // make drawing in css pixels
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 120));
resizeCanvas();

// Utility functions
function rand(min, max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// Fruit class (circle)
class Fruit {
  constructor(x, y, vx, vy, radius, color, spin) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.radius = radius; this.color = color; this.spin = spin; // rotation speed
    this.angle = 0;
    this.sliced = false;
    this.id = Math.random().toString(36).slice(2,9);
  }
  update(dt) {
    this.vy += 600 * dt; // gravity
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.angle += this.spin * dt;
  }
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    // ring outline
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(0, 0, this.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = Math.max(2, this.radius*0.14);
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.stroke();
    // little shine
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.ellipse(-this.radius*0.28, -this.radius*0.28, this.radius*0.28, this.radius*0.16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

// Particle for cut effect
class Particle {
  constructor(x,y,vx,vy,life,color,radius){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.life=life;this.maxLife=life;
    this.color=color;this.radius=radius;
  }
  update(dt){
    this.vy += 1400*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
    this.life -= dt;
  }
  draw(ctx){
    const t = clamp(this.life/this.maxLife,0,1);
    ctx.beginPath();
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Spawn fruit from bottom with upward velocity
function spawnFruit() {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  // random x within screen
  const x = rand(40, w-40);
  // start y slightly below bottom to pop up
  const y = h + 30;
  // upward velocity random
  const vy = rand(-950, -700);
  // random horizontal velocity
  const vx = rand(-140, 140);
  const radius = rand(Math.max(18, w/28), Math.max(26, w/14));
  const colors = ['#FF3B30','#FF9500','#34C759','#5AC8FA','#5E5CE6','#AF52DE','#FFD60A','#FF2D55','#32D74B'];
  const color = colors[Math.floor(rand(0, colors.length))];
  const spin = rand(-6,6);
  fruits.push(new Fruit(x,y,vx,vy,radius,color,spin));
}

// Intersection: distance point to segment
function distPointSegment(px,py,x1,y1,x2,y2) {
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const lenSq = C*C + D*D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.sqrt(dx*dx + dy*dy);
}

// Handle slice detection
function processSliceLine(a,b){
  let cuts = 0;
  for (let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    if (f.sliced) continue;
    const d = distPointSegment(f.x,f.y,a.x,a.y,b.x,b.y);
    if (d <= f.radius * 0.92) {
      // slice!
      f.sliced = true;
      cuts++;
      combos++;
      lastCutTime = performance.now();
      // add score (combo multiplies)
      const gained = Math.floor(1 + Math.min(10, f.radius/6) + Math.floor(combos/4));
      score += gained;
      // create particles
      for (let p=0;p<10;p++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(120, 420);
        const vx = Math.cos(ang)*spd + f.vx*0.1;
        const vy = Math.sin(ang)*spd + f.vy*0.1;
        particles.push(new Particle(f.x + Math.cos(ang)*4, f.y + Math.sin(ang)*4, vx, vy, rand(0.4,0.9), f.color, Math.max(2, f.radius/12)));
      }
      // small screen shake by applying temporary offset
      screenShake = clamp(screenShake + 6, 0, 16);

      // remove fruit immediately (lighter)
      fruits.splice(i,1);
      // optionally: play sound here
    }
  }
  if (cuts === 0) {
    combos = 0; // reset combos if missed
  }
  return cuts;
}

// Input handling (touch + mouse)
let isDown = false;
let lastPos = null;
const maxTrail = 14;

function pointerDown(x,y){
  isDown = true;
  lastPos = {x,y,t:performance.now()};
  mouseTrail = [{x,y,t:performance.now()}];
}
function pointerMove(x,y){
  if(!isDown) return;
  const now = performance.now();
  const pos = {x,y,t:now};
  // keep short trail for drawing swipe
  mouseTrail.push(pos);
  if (mouseTrail.length > maxTrail) mouseTrail.shift();

  // check immediate segment collision between last two points
  const a = mouseTrail[Math.max(0, mouseTrail.length-2)];
  const b = mouseTrail[mouseTrail.length-1];
  if (a && b) processSliceLine(a,b);

  lastPos = pos;
}
function pointerUp(x,y){
  isDown = false;
  if (mouseTrail.length >= 2) {
    // final pass across segments
    for (let i=0;i<mouseTrail.length-1;i++){
      processSliceLine(mouseTrail[i], mouseTrail[i+1]);
    }
  }
  mouseTrail = [];
}

// Mouse events
canvas.addEventListener('mousedown', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  pointerDown(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  pointerMove(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener('mouseup', e=>{
  const r = canvas.getBoundingClientRect();
  pointerUp(e.clientX - r.left, e.clientY - r.top);
});

// Touch events (mobile)
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0];
  pointerDown(t.clientX - r.left, t.clientY - r.top);
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0];
  pointerMove(t.clientX - r.left, t.clientY - r.top);
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0] || e.touches[0];
  pointerUp(t ? t.clientX - r.left : 0, t? t.clientY - r.top : 0);
}, {passive:false});

// Game loop
let last = performance.now();
let screenShake = 0;
function loop(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  if (!paused) {
    update(dt);
  }
  draw();
  requestAnimationFrame(loop);
}

// update state
function update(dt){
  // time
  gameTime -= dt;
  if (gameTime <= 0) {
    gameTime = 0;
    paused = true;
  }

  // spawn fruits periodically (shorter interval on bigger screen)
  lastSpawn += dt;
  const spawnInterval = clamp(0.6 - Math.min(0.3, score/110), 0.2, 1.2);
  if (lastSpawn > spawnInterval) {
    lastSpawn = 0;
    // spawn 1-2 fruits
    const how = (Math.random() < 0.12) ? 2 : 1;
    for (let i=0;i<how;i++) spawnFruit();
  }

  // update fruits
  for (let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    f.update(dt);
    // remove if out of screen bottom or too left/right
    if (f.y - f.radius > canvas.clientHeight + 100 || f.x + f.radius < -80 || f.x - f.radius > canvas.clientWidth + 80) {
      fruits.splice(i,1);
      combos = 0; // missed fruit resets combo
      continue;
    }
  }

  // update particles
  for (let i=particles.length-1;i>=0;i--){
    particles[i].update(dt);
    if (particles[i].life <= 0) particles.splice(i,1);
  }

  // decay screen shake
  screenShake = Math.max(0, screenShake - dt*24);

  // hud update
  scoreEl.textContent = score;
  timeEl.textContent = Math.ceil(gameTime);
  timeLabel.textContent = Math.ceil(gameTime);
  // reset combos if time since last cut > 900ms
  if (performance.now() - lastCutTime > 900) combos = 0;
}

// draw everything
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw gradient background (in css already) - add soft pattern
  // apply screen shake transform
  ctx.save();
  const sx = rand(-screenShake, screenShake) * 0.25;
  const sy = rand(-screenShake, screenShake) * 0.25;
  ctx.translate(sx, sy);

  // draw fruits
  for (const f of fruits) f.draw(ctx);

  // draw particles on top
  for (const p of particles) p.draw(ctx);

  // draw swipe trail
  if (mouseTrail.length > 0) {
    ctx.beginPath();
    for (let i=0;i<mouseTrail.length;i++){
      const t = mouseTrail[i];
      if (i===0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.stroke();

    // bright part
    ctx.beginPath();
    for (let i=0;i<mouseTrail.length;i++){
      const t = mouseTrail[i];
      if (i===0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.stroke();
  }

  ctx.restore();
}

// buttons
document.getElementById('restartBtn').addEventListener('click', ()=>{
  restartGame();
});
document.getElementById('pauseBtn').addEventListener('click', (e)=>{
  paused = !paused;
  e.target.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
});
document.getElementById('menuBtn').addEventListener('click', ()=>{
  // simple menu toggle - show quick info
  alert('Game Controls:\\n- Swipe on the screen to cut fruits.\\n- Tap Pause to pause.\\n- Restart to play again.\\nEnjoy!');
});

// restart
function restartGame(){
  fruits = []; particles = []; mouseTrail = [];
  score = 0; gameTime = 60; paused = false; lastSpawn = 0; combos = 0;
  document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
}

// initial few fruits
for (let i=0;i<3;i++) spawnFruit();

// ensure canvas CSS size is set to parent size so drawing coords match
function setCanvasCSSSize(){
  // make canvas element occupy full parent
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  resizeCanvas();
}
setCanvasCSSSize();
window.addEventListener('resize', setCanvasCSSSize);

// kick loop
requestAnimationFrame(loop);
</script>
</body>
</html><!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Cut fruit ‚Äî Mobile Friendly</title>
<style>
  /* Basic reset */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:linear-gradient(180deg,#ffd1c1,#ff6f6f);font-family:Inter,system-ui,Arial,sans-serif;color:#111}
  /* App shell */
  .app {
    display:flex;
    flex-direction:column;
    height:100vh;
    overflow:hidden;
  }

  /* Top bar */
  header{
    height:56px;
    display:flex;
    align-items:center;
    gap:12px;
    padding:0 12px;
    background:rgba(0,0,0,0.85);
    color:#fff;
    box-shadow:0 2px 10px rgba(0,0,0,0.25);
    z-index:20;
  }
  .menu {
    width:36px;height:36px;border-radius:8px;border:2px solid rgba(255,255,255,0.12);
    display:flex;align-items:center;justify-content:center;
    cursor:pointer; backdrop-filter:blur(4px);
    transition:transform .18s ease;
  }
  .menu:active{transform:scale(.94)}
  .title{font-weight:600;font-size:18px}
  .top-right {
    margin-left:auto;display:flex;align-items:center;gap:10px;
  }
  /* outlined buttons */
  .btn {
    border-radius:10px;padding:8px 12px;border:2px solid rgba(255,255,255,0.85);
    background:transparent;color:#fff;font-weight:600;font-size:14px;
    display:inline-flex;align-items:center;gap:8px;cursor:pointer;
    transition:transform .18s ease, box-shadow .18s;
    position:relative;overflow:hidden;
  }
  .btn:active{transform:translateY(2px) scale(.98)}
  /* small ripple animation for click */
  .btn::after{
    content:"";position:absolute;width:0;height:0;border-radius:50%;background:rgba(255,255,255,0.12);
    transition:width .35s ease,height .35s ease,opacity .45s;opacity:0;
  }
  .btn:focus::after{opacity:1;width:200px;height:200px;left:-50px;top:-50px;}

  /* game area */
  .game-wrap{flex:1;position:relative;display:flex;align-items:stretch;justify-content:center;}
  canvas{
    display:block;
    width:100%;
    height:100%;
    touch-action:none; /* allow custom touch handling */
    background:linear-gradient(180deg, rgba(255,120,100,0.08), rgba(255,40,80,0.05));
  }

  /* overlay info */
  .hud{
    position:absolute;top:14px;left:50%;transform:translateX(-50%);z-index:18;
    display:flex;align-items:center;gap:10px;padding:6px 12px;border-radius:12px;
    background:rgba(255,255,255,0.92);box-shadow:0 6px 18px rgba(0,0,0,0.15);
    font-weight:700;color:#222;
  }
  .score {display:flex;align-items:center;gap:8px;font-size:18px}
  .time {font-size:14px;color:#666;font-weight:600}

  /* bottom controls for mobile */
  .controls{
    position:absolute;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:18;
  }

  /* small rounded pill for coin/time display */
  .pill{
    border-radius:999px;padding:6px 10px;border:2px solid rgba(0,0,0,0.06);background:rgba(255,255,255,0.95);
    font-weight:700;color:#222;display:inline-flex;align-items:center;gap:8px;
  }

  /* responsive text sizes */
  @media (max-width:420px){
    .title{font-size:16px}
    .hud{padding:4px 8px}
    .score{font-size:16px}
    .btn{padding:6px 10px;font-size:13px}
  }

  /* small fade in */
  .fade-in{animation:fadein .45s ease}
  @keyframes fadein{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="menu" id="menuBtn" title="Menu">
      ‚ò∞
    </div>
    <div class="title">Cut fruit</div>
    <div class="top-right">
      <div class="pill">‚è± <span id="timeLabel">60</span>s</div>
      <button class="btn" id="restartBtn">‚ôª Restart</button>
    </div>
  </header>

  <div class="game-wrap">
    <canvas id="game"></canvas>

    <div class="hud fade-in">
      <div class="score">üéØ Score: <span id="score">0</span></div>
      <div style="width:10px"></div>
      <div class="time">‚è≥ <span id="time">60</span>s</div>
    </div>

    <div class="controls">
      <button class="btn" id="pauseBtn">‚è∏ Pause</button>
      <button class="btn" id="shopBtn">üõí Shop</button>
    </div>
  </div>
</div>

<script>
/* ----------------------------
   Mobile-friendly Fruit Cut Game
   Hindi comments diye hue hain
   ---------------------------- */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = Math.max(1, window.devicePixelRatio || 1);

// HUD
const scoreEl = document.getElementById('score');
const timeEl = document.getElementById('time');
const timeLabel = document.getElementById('timeLabel');

let score = 0;
let gameTime = 60; // seconds
let paused = false;
let lastSpawn = 0;
let fruits = [];
let particles = [];
let mouseTrail = []; // for swipe line
let combos = 0;
let lastCutTime = 0;

// Canvas resize to fit container while preserving resolution
function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // make drawing in css pixels
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 120));
resizeCanvas();

// Utility functions
function rand(min, max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// Fruit class (circle)
class Fruit {
  constructor(x, y, vx, vy, radius, color, spin) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.radius = radius; this.color = color; this.spin = spin; // rotation speed
    this.angle = 0;
    this.sliced = false;
    this.id = Math.random().toString(36).slice(2,9);
  }
  update(dt) {
    this.vy += 600 * dt; // gravity
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.angle += this.spin * dt;
  }
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    // ring outline
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(0, 0, this.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = Math.max(2, this.radius*0.14);
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.stroke();
    // little shine
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.ellipse(-this.radius*0.28, -this.radius*0.28, this.radius*0.28, this.radius*0.16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

// Particle for cut effect
class Particle {
  constructor(x,y,vx,vy,life,color,radius){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.life=life;this.maxLife=life;
    this.color=color;this.radius=radius;
  }
  update(dt){
    this.vy += 1400*dt;
    this.x += this.vx*dt; this.y += this.vy*dt;
    this.life -= dt;
  }
  draw(ctx){
    const t = clamp(this.life/this.maxLife,0,1);
    ctx.beginPath();
    ctx.globalAlpha = t;
    ctx.fillStyle = this.color;
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Spawn fruit from bottom with upward velocity
function spawnFruit() {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  // random x within screen
  const x = rand(40, w-40);
  // start y slightly below bottom to pop up
  const y = h + 30;
  // upward velocity random
  const vy = rand(-950, -700);
  // random horizontal velocity
  const vx = rand(-140, 140);
  const radius = rand(Math.max(18, w/28), Math.max(26, w/14));
  const colors = ['#FF3B30','#FF9500','#34C759','#5AC8FA','#5E5CE6','#AF52DE','#FFD60A','#FF2D55','#32D74B'];
  const color = colors[Math.floor(rand(0, colors.length))];
  const spin = rand(-6,6);
  fruits.push(new Fruit(x,y,vx,vy,radius,color,spin));
}

// Intersection: distance point to segment
function distPointSegment(px,py,x1,y1,x2,y2) {
  const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
  const dot = A*C + B*D;
  const lenSq = C*C + D*D;
  let param = -1;
  if (lenSq !== 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  const dx = px - xx, dy = py - yy;
  return Math.sqrt(dx*dx + dy*dy);
}

// Handle slice detection
function processSliceLine(a,b){
  let cuts = 0;
  for (let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    if (f.sliced) continue;
    const d = distPointSegment(f.x,f.y,a.x,a.y,b.x,b.y);
    if (d <= f.radius * 0.92) {
      // slice!
      f.sliced = true;
      cuts++;
      combos++;
      lastCutTime = performance.now();
      // add score (combo multiplies)
      const gained = Math.floor(1 + Math.min(10, f.radius/6) + Math.floor(combos/4));
      score += gained;
      // create particles
      for (let p=0;p<10;p++){
        const ang = rand(0, Math.PI*2);
        const spd = rand(120, 420);
        const vx = Math.cos(ang)*spd + f.vx*0.1;
        const vy = Math.sin(ang)*spd + f.vy*0.1;
        particles.push(new Particle(f.x + Math.cos(ang)*4, f.y + Math.sin(ang)*4, vx, vy, rand(0.4,0.9), f.color, Math.max(2, f.radius/12)));
      }
      // small screen shake by applying temporary offset
      screenShake = clamp(screenShake + 6, 0, 16);

      // remove fruit immediately (lighter)
      fruits.splice(i,1);
      // optionally: play sound here
    }
  }
  if (cuts === 0) {
    combos = 0; // reset combos if missed
  }
  return cuts;
}

// Input handling (touch + mouse)
let isDown = false;
let lastPos = null;
const maxTrail = 14;

function pointerDown(x,y){
  isDown = true;
  lastPos = {x,y,t:performance.now()};
  mouseTrail = [{x,y,t:performance.now()}];
}
function pointerMove(x,y){
  if(!isDown) return;
  const now = performance.now();
  const pos = {x,y,t:now};
  // keep short trail for drawing swipe
  mouseTrail.push(pos);
  if (mouseTrail.length > maxTrail) mouseTrail.shift();

  // check immediate segment collision between last two points
  const a = mouseTrail[Math.max(0, mouseTrail.length-2)];
  const b = mouseTrail[mouseTrail.length-1];
  if (a && b) processSliceLine(a,b);

  lastPos = pos;
}
function pointerUp(x,y){
  isDown = false;
  if (mouseTrail.length >= 2) {
    // final pass across segments
    for (let i=0;i<mouseTrail.length-1;i++){
      processSliceLine(mouseTrail[i], mouseTrail[i+1]);
    }
  }
  mouseTrail = [];
}

// Mouse events
canvas.addEventListener('mousedown', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  pointerDown(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  pointerMove(e.clientX - r.left, e.clientY - r.top);
});
window.addEventListener('mouseup', e=>{
  const r = canvas.getBoundingClientRect();
  pointerUp(e.clientX - r.left, e.clientY - r.top);
});

// Touch events (mobile)
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0];
  pointerDown(t.clientX - r.left, t.clientY - r.top);
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0];
  pointerMove(t.clientX - r.left, t.clientY - r.top);
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  e.preventDefault();
  const r = canvas.getBoundingClientRect();
  const t = e.changedTouches[0] || e.touches[0];
  pointerUp(t ? t.clientX - r.left : 0, t? t.clientY - r.top : 0);
}, {passive:false});

// Game loop
let last = performance.now();
let screenShake = 0;
function loop(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  if (!paused) {
    update(dt);
  }
  draw();
  requestAnimationFrame(loop);
}

// update state
function update(dt){
  // time
  gameTime -= dt;
  if (gameTime <= 0) {
    gameTime = 0;
    paused = true;
  }

  // spawn fruits periodically (shorter interval on bigger screen)
  lastSpawn += dt;
  const spawnInterval = clamp(0.6 - Math.min(0.3, score/110), 0.2, 1.2);
  if (lastSpawn > spawnInterval) {
    lastSpawn = 0;
    // spawn 1-2 fruits
    const how = (Math.random() < 0.12) ? 2 : 1;
    for (let i=0;i<how;i++) spawnFruit();
  }

  // update fruits
  for (let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    f.update(dt);
    // remove if out of screen bottom or too left/right
    if (f.y - f.radius > canvas.clientHeight + 100 || f.x + f.radius < -80 || f.x - f.radius > canvas.clientWidth + 80) {
      fruits.splice(i,1);
      combos = 0; // missed fruit resets combo
      continue;
    }
  }

  // update particles
  for (let i=particles.length-1;i>=0;i--){
    particles[i].update(dt);
    if (particles[i].life <= 0) particles.splice(i,1);
  }

  // decay screen shake
  screenShake = Math.max(0, screenShake - dt*24);

  // hud update
  scoreEl.textContent = score;
  timeEl.textContent = Math.ceil(gameTime);
  timeLabel.textContent = Math.ceil(gameTime);
  // reset combos if time since last cut > 900ms
  if (performance.now() - lastCutTime > 900) combos = 0;
}

// draw everything
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw gradient background (in css already) - add soft pattern
  // apply screen shake transform
  ctx.save();
  const sx = rand(-screenShake, screenShake) * 0.25;
  const sy = rand(-screenShake, screenShake) * 0.25;
  ctx.translate(sx, sy);

  // draw fruits
  for (const f of fruits) f.draw(ctx);

  // draw particles on top
  for (const p of particles) p.draw(ctx);

  // draw swipe trail
  if (mouseTrail.length > 0) {
    ctx.beginPath();
    for (let i=0;i<mouseTrail.length;i++){
      const t = mouseTrail[i];
      if (i===0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.stroke();

    // bright part
    ctx.beginPath();
    for (let i=0;i<mouseTrail.length;i++){
      const t = mouseTrail[i];
      if (i===0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.stroke();
  }

  ctx.restore();
}

// buttons
document.getElementById('restartBtn').addEventListener('click', ()=>{
  restartGame();
});
document.getElementById('pauseBtn').addEventListener('click', (e)=>{
  paused = !paused;
  e.target.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
});
document.getElementById('menuBtn').addEventListener('click', ()=>{
  // simple menu toggle - show quick info
  alert('Game Controls:\\n- Swipe on the screen to cut fruits.\\n- Tap Pause to pause.\\n- Restart to play again.\\nEnjoy!');
});

// restart
function restartGame(){
  fruits = []; particles = []; mouseTrail = [];
  score = 0; gameTime = 60; paused = false; lastSpawn = 0; combos = 0;
  document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
}

// initial few fruits
for (let i=0;i<3;i++) spawnFruit();

// ensure canvas CSS size is set to parent size so drawing coords match
function setCanvasCSSSize(){
  // make canvas element occupy full parent
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  resizeCanvas();
}
setCanvasCSSSize();
window.addEventListener('resize', setCanvasCSSSize);

// kick loop
requestAnimationFrame(loop);
</script>
</body>
</html>
