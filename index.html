<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cut Fruit ‚Äî Fruit Ninja Style</title>
<style>
  /* ‡§¨‡•á‡§∏‡§ø‡§ï ‡§∏‡•ç‡§ü‡§æ‡§á‡§≤ */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: linear-gradient(180deg,#0b1020,#061022);
    color:#fff;
    display:flex;align-items:center;justify-content:center;
    padding:12px;
  }

  /* ‡§ï‡§Ç‡§ü‡•á‡§®‡§∞ */
  .wrap{
    width:100%;max-width:980px;height:calc(100vh - 24px);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;position:relative;overflow:hidden;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  }

  /* HUD */
  .hud{position:absolute;top:10px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:60}
  .panel{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,0.04);font-weight:700}
  .title{font-size:20px;color:#ffb6b6}
  .small{font-size:14px;color:#dbeafe}

  /* Home overlay */
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:70}
  .home{flex-direction:column;gap:12px;text-align:center;padding:20px}
  .btn{padding:12px 28px;border-radius:999px;border:2px solid rgba(255,120,120,0.9);background:transparent;color:#fff;cursor:pointer;font-weight:800}
  .btn:hover{background:rgba(255,120,120,0.12)}
  .credit{position:absolute;left:12px;bottom:8px;font-size:13px;color:#ddd}

  /* canvas */
  #gameCanvas{position:absolute;left:8px;right:8px;top:64px;bottom:12px;border-radius:10px;background:#000;touch-action:none;z-index:10;}

  /* gameover styles */
  .gameOver{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:100}
  .gameOver .box{background:rgba(0,0,0,0.75);padding:22px;border-radius:12px;text-align:center}
  .gameOver h2{margin-bottom:8px}
  .controls{display:flex;gap:10px;justify-content:center;margin-top:10px}

  /* small screens */
  @media (max-width:520px){
    .title{font-size:16px}
    .btn{padding:10px 18px}
  }
</style>
</head>
<body>

<div class="wrap" id="wrap">
  <div class="hud">
    <div style="display:flex;gap:10px;align-items:center">
      <div class="panel title">üçâ Cut Fruit</div>
      <div class="panel small" id="comboPanel">Combo: 0</div>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <div class="panel small" id="scorePanel">Score: 0</div>
      <div class="panel small" id="timePanel">Time: 60</div>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- Home overlay -->
  <div class="overlay home" id="homeOverlay">
    <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
      <div style="font-size:48px;color:#ff8a8a">üçì Cut Fruit</div>
      <div style="color:#dbeafe">Fruit Ninja ‡§ú‡•à‡§∏‡§æ ‡§Ö‡§®‡•Å‡§≠‡§µ ‚Äî swipe ‡§ï‡§∞‡•ã ‡§î‡§∞ ‡§∏‡§≠‡•Ä ‡§´‡§≤ ‡§ï‡§æ‡§ü‡•ã!</div>
    </div>
    <div style="display:flex;gap:10px;margin-top:12px">
      <button class="btn" id="startBtn">‚ñ∂ Start</button>
      <button class="btn" id="howBtn">‚ùî How</button>
    </div>
    <div style="margin-top:10px;color:#d0e8ff">Choose Game Over Style:
      <select id="styleChoice" style="margin-left:8px;padding:6px;border-radius:8px">
        <option value="simple">Simple</option>
        <option value="neon">Neon</option>
      </select>
    </div>
    <div class="credit">Made by Arun Dhakad</div>
  </div>

  <!-- Game Over -->
  <div class="gameOver" id="gameOver">
    <div class="box" id="gameOverBox">
      <h2 id="goTitle">Game Over</h2>
      <div id="finalScore" style="font-weight:800;font-size:18px;margin-bottom:6px"></div>
      <div id="bestScore" style="margin-bottom:8px;color:#cfeaff"></div>
      <div class="controls">
        <button class="btn" id="replayBtn">üîÑ Replay</button>
        <button class="btn" id="homeBtn">üè† Home</button>
      </div>
    </div>
  </div>
</div>

<!-- Audio (base64 small sounds) -->
<audio id="sliceAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
<audio id="bombAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>

<script>
/* ======= Fruit Ninja-like Game (Hindi comments) ======= */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('wrap');

// UI
const homeOverlay = document.getElementById('homeOverlay');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
const scorePanel = document.getElementById('scorePanel');
const timePanel = document.getElementById('timePanel');
const comboPanel = document.getElementById('comboPanel');
const gameOverDiv = document.getElementById('gameOver');
const goTitle = document.getElementById('goTitle');
const finalScore = document.getElementById('finalScore');
const bestScore = document.getElementById('bestScore');
const replayBtn = document.getElementById('replayBtn');
const homeBtn = document.getElementById('homeBtn');
const styleChoice = document.getElementById('styleChoice');

// sounds (placeholders small silent; you can replace with real base64 sounds)
const sliceAudio = document.getElementById('sliceAudio');
const bombAudio = document.getElementById('bombAudio');

// resize canvas to wrap area leaving HUD (top 64px)
function resize(){
  const r = wrap.getBoundingClientRect();
  canvas.width = Math.floor(r.width - 16);
  canvas.height = Math.floor(r.height - 86);
}
window.addEventListener('resize', resize);
resize();

// game state
let fruits = [];    // fruits & powerups
let pieces = [];    // sliced halves
let particles = []; // juice particles
let sliceTrails = []; // persistent slice lines
let score = 0;
let combo = 0;
let comboTimer = 0;
let remaining = 60;
let timerInterval = null;
let playing = false;
let lastTime = 0;
let spawnAccumulator = 0;
let pointerDown = false;
let tracks = []; // swipe track points
let swipePath = []; // visible trail
let slowUntil = 0; // slow motion timestamp

// emoji sets
const FRUITS = ["üçé","üçä","üçå","üçâ","üçì","üçë"];
const POWERS = ["üí£","‚è±Ô∏è","üçÄ"]; // bomb, time-freeze, slice-all

// random helper
const rand = (a,b)=> a + Math.random()*(b-a);

// Fruit class
class Fruit {
  constructor(type='fruit'){
    this.x = rand(60, canvas.width-60);
    this.y = canvas.height + 40;
    this.r = rand(26,36);
    this.vx = rand(-3.5,3.5);
    this.vy = rand(13,18); // upward
    this.gravity = 0.45;
    this.angle = rand(0,Math.PI*2);
    this.angular = rand(-0.18,0.18);
    this.type = type; // 'fruit' or 'power'
    this.emoji = (this.type==='fruit') ? FRUITS[Math.floor(rand(0,FRUITS.length))] : POWERS[Math.floor(rand(0,POWERS.length))];
    this.alive = true;
    this.spawn = Date.now();
  }
  update(dt){
    const slow = Date.now() < slowUntil ? 0.45 : 1;
    this.x += this.vx * (dt/16) * slow;
    this.y -= this.vy * (dt/16) * slow;
    this.vy -= this.gravity * (dt/16) * slow;
    this.angle += this.angular * (dt/16) * slow;
    if(this.y > canvas.height + 80) this.alive = false;
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.font = `${this.r*2}px serif`;
    ctx.textAlign = 'center';
    ctx.fillText(this.emoji, 0, 0);
    ctx.restore();
  }
}

// spawn multiple fruits at once (1-4)
function spawnWave(){
  const count = Math.floor(rand(1,4)); // 1 to 3
  for(let i=0;i<count;i++){
    if(Math.random() < 0.12) fruits.push(new Fruit('power'));
    else fruits.push(new Fruit('fruit'));
  }
}

// slice effects
function addSliceTrail(x1,y1,x2,y2){
  sliceTrails.push({x1,y1,x2,y2,ttl:360,alpha:1});
}

// particles (juice)
function spawnParticles(x,y,emoji){
  const c = (emoji==='üçì' || emoji==='üçé') ? 'rgba(255,90,110,0.95)' : 'rgba(255,200,80,0.95)';
  for(let i=0;i<14;i++){
    particles.push({
      x: x + rand(-8,8),
      y: y + rand(-8,8),
      vx: rand(-6,6),
      vy: rand(2,10),
      life: 300 + rand(0,300),
      c: c,
      size: rand(3,7)
    });
  }
}

// when fruit sliced
function sliceFruitAt(index, mx, my){
  const f = fruits[index];
  if(!f) return;
  // powerups handling
  if(f.type === 'power'){
    if(f.emoji === 'üí£'){
      // bomb -> explosion and game over
      for(let i=0;i<28;i++) particles.push({
        x:f.x,y:f.y,vx:rand(-8,8),vy:rand(-2,10),life:300+rand(0,300),c:'rgba(255,200,60,0.95)',size:rand(4,8)
      });
      bombAudio.currentTime = 0; try{ bombAudio.play(); }catch(e){}
      endGame(true);
      return;
    } else if(f.emoji === '‚è±Ô∏è'){
      slowUntil = Date.now() + 4500;
      score += 12;
      combo++; comboTimer = Date.now();
      fruits.splice(index,1);
      refreshUI();
      sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
      return;
    } else if(f.emoji === 'üçÄ'){
      // slice all: score all fruits
      score += fruits.length * 10;
      spawnParticles(f.x,f.y,'üçÄ');
      fruits = [];
      combo++; comboTimer = Date.now();
      refreshUI();
      sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
      return;
    }
  }

  // normal fruit -> create two pieces & particles
  pieces.push({x:f.x-8,y:f.y,vx:-rand(2,6),vy:rand(6,12),ang:rand(-0.3,0.3),emoji:f.emoji,life:800});
  pieces.push({x:f.x+8,y:f.y,vx:rand(2,6),vy:rand(6,12),ang:rand(-0.3,0.3),emoji:f.emoji,life:800});
  spawnParticles(f.x,f.y,f.emoji);
  addSliceTrail(mx-30,my-10,mx+30,my+10);
  score += 10;
  combo++; comboTimer = Date.now();
  fruits.splice(index,1);
  sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
  refreshUI();
}

// UI update
function refreshUI(){
  scorePanel.innerText = 'Score: ' + score;
  comboPanel.innerText = 'Combo: ' + (combo>0?combo:0);
}

// slow motion helper
function slowMotion(ms){ slowUntil = Date.now() + ms; }

// handle swipe segment collision with fruits
function handleSegment(p1,p2){
  let slicedCount = 0;
  for(let i = fruits.length-1; i >= 0; i--){
    const f = fruits[i];
    // distance from point to segment
    const px = f.x, py = f.y;
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if(len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if(param < 0){ xx = x1; yy = y1; }
    else if(param > 1){ xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx, dy = py - yy;
    const d = Math.sqrt(dx*dx + dy*dy);
    if(d < f.r * 0.85){
      const mx = (x1 + x2)/2, my = (y1 + y2)/2;
      sliceFruitAt(i, mx, my);
      slicedCount++;
    }
  }
  // combo bonus if multiple in same segment
  if(slicedCount >= 2){
    const bonus = slicedCount * 5;
    score += bonus;
    refreshUI();
  }
  return slicedCount;
}

/* ===== Input handling (touch & mouse) ===== */
canvas.addEventListener('mousedown', e=>{
  if(!playing) return;
  const r = canvas.getBoundingClientRect();
  pointerDown = true;
  tracks = [{x:e.clientX - r.left, y: e.clientY - r.top, t:Date.now()}];
  swipePath = [{x:e.clientX - r.left, y: e.clientY - r.top}];
});
window.addEventListener('mousemove', e=>{
  if(!playing || !pointerDown) return;
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;
  tracks.push({x,y,t:Date.now()});
  if(tracks.length > 30) tracks.shift();
  swipePath.push({x,y}); if(swipePath.length>30) swipePath.shift();
  // check only last segment
  if(tracks.length > 1) handleSegment(tracks[tracks.length-2], tracks[tracks.length-1]);
});
window.addEventListener('mouseup', e=>{
  if(!playing) return;
  pointerDown = false;
  tracks = [];
  setTimeout(()=> swipePath = [], 120);
});

canvas.addEventListener('touchstart', e=>{
  if(!playing) return;
  const t = e.touches[0]; const r = canvas.getBoundingClientRect();
  pointerDown = true;
  tracks = [{x:t.clientX - r.left, y: t.clientY - r.top, t:Date.now()}];
  swipePath = [{x:t.clientX - r.left, y: t.clientY - r.top}];
});
canvas.addEventListener('touchmove', e=>{
  if(!playing || !pointerDown) return;
  const t = e.touches[0]; const r = canvas.getBoundingClientRect();
  const x = t.clientX - r.left, y = t.clientY - r.top;
  tracks.push({x,y,t:Date.now()});
  if(tracks.length > 30) tracks.shift();
  swipePath.push({x,y}); if(swipePath.length>30) swipePath.shift();
  if(tracks.length > 1) handleSegment(tracks[tracks.length-2], tracks[tracks.length-1]);
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  if(!playing) return;
  pointerDown = false;
  tracks = [];
  setTimeout(()=> swipePath = [], 120);
});

/* ===== pieces & particles update/draw ===== */
function updatePieces(dt){
  for(let i=pieces.length-1;i>=0;i--){
    const p = pieces[i];
    p.x += p.vx * (dt/16);
    p.y -= p.vy * (dt/16);
    p.vy -= 0.4 * (dt/16);
    p.ang += 0.03 * (dt/16);
    p.life -= dt;
    if(p.life <= 0) pieces.splice(i,1);
  }
}
function drawPieces(ctx){
  for(const p of pieces){
    ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.ang); ctx.font='28px serif'; ctx.textAlign='center'; ctx.fillText(p.emoji,0,0); ctx.restore();
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx * (dt/16);
    p.y -= p.vy * (dt/16);
    p.vy -= 0.2 * (dt/16);
    p.life -= dt;
    if(p.life <= 0) particles.splice(i,1);
  }
}
function drawParticles(ctx){
  for(const p of particles){
    ctx.save(); ctx.globalAlpha = Math.max(0, p.life/600); ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
}

/* ===== slice trails draw & update ===== */
function drawSwipeTrail(ctx){
  if(swipePath.length < 2) return;
  ctx.save(); ctx.lineJoin = ctx.lineCap = 'round';
  // main white trail
  ctx.globalAlpha = 0.9; ctx.lineWidth = 8;
  const g = ctx.createLinearGradient(swipePath[0].x, swipePath[0].y, swipePath[swipePath.length-1].x, swipePath[swipePath.length-1].y);
  g.addColorStop(0, 'rgba(255,255,255,0.95)'); g.addColorStop(1, 'rgba(0,200,255,0.4)');
  ctx.strokeStyle = g; ctx.beginPath();
  for(let i=0;i<swipePath.length;i++){ const p=swipePath[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
  ctx.stroke();
  // faint secondary
  ctx.lineWidth = 3; ctx.globalAlpha = 0.25; ctx.strokeStyle = 'rgba(0,200,255,0.6)'; ctx.beginPath();
  for(let i=0;i<swipePath.length;i++){ const p=swipePath[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
  ctx.stroke();
  ctx.restore();
}
function updateSliceTrails(dt){
  for(let i=sliceTrails.length-1;i>=0;i--){
    const s = sliceTrails[i];
    s.ttl -= dt; s.alpha = Math.max(0, s.ttl/360);
    if(s.ttl <= 0) sliceTrails.splice(i,1);
  }
}
function drawSliceTrails(ctx){
  for(const s of sliceTrails){
    ctx.save();
    ctx.lineWidth = 6; ctx.strokeStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.shadowBlur = 10; ctx.shadowColor = 'white';
    ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
    ctx.restore();
  }
}

/* ===== main loop ===== */
function gameLoop(now){
  if(!playing) return;
  if(!lastTime) lastTime = now;
  const dt = now - lastTime; lastTime = now;

  // spawn logic: faster if not slow
  spawnAccumulator += dt;
  const spawnInterval = (Date.now() < slowUntil) ? 700*1.6 : 700;
  if(spawnAccumulator > spawnInterval){
    spawnAccumulator = 0;
    // spawn a wave
    spawnWave();
  }

  // update entities
  for(const f of fruits) f.update(dt);
  updatePieces(dt);
  updateParticles(dt);
  updateSliceTrails(dt);

  // remove dead fruits
  fruits = fruits.filter(f => f.alive);

  // combo reset & small bonus when combo finishes
  if(combo>0 && Date.now() - comboTimer > 900){
    if(combo >= 2){ score += combo * 5; refreshUI(); }
    combo = 0; comboPanel.innerText = 'Combo: 0';
  }

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const f of fruits) f.draw(ctx);
  drawPieces(ctx);
  drawParticles(ctx);
  drawSliceTrails(ctx);
  drawSwipeTrail(ctx);

  requestAnimationFrame(gameLoop);
}

/* ===== game control functions ===== */
function refreshPanels(){
  scorePanel.innerText = 'Score: ' + score;
  timePanel.innerText = 'Time: ' + remaining;
  comboPanel.innerText = 'Combo: ' + (combo>0?combo:0);
}

function startGame(){
  // reset
  fruits = []; pieces = []; particles = []; sliceTrails = [];
  score = 0; combo = 0; comboTimer = 0; remaining = 60; refreshPanels();
  homeOverlay.style.display = 'none';
  gameOverDiv.style.display = 'none';
  playing = true; lastTime = 0; spawnAccumulator = 0;
  // start timer
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    if(!playing) return;
    remaining--; timePanel.innerText = 'Time: ' + remaining;
    if(remaining <= 0) endGame(false);
  }, 1000);
  requestAnimationFrame(gameLoop);
}
function endGame(isBomb=false){
  playing = false;
  if(timerInterval) clearInterval(timerInterval);
  // update high score
  let best = parseInt(localStorage.getItem('cutFruitHighScore') || '0', 10);
  if(score > best){ best = score; localStorage.setItem('cutFruitHighScore', best); }
  // show Game Over with chosen style
  const style = styleChoice.value || 'simple';
  const go = document.getElementById('gameOver');
  const box = document.getElementById('gameOverBox');
  // apply styles
  if(style === 'neon'){
    go.style.display = 'flex'; go.querySelector('.box').style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4))';
    go.querySelector('.box').style.boxShadow = '0 8px 40px rgba(0,255,255,0.06), inset 0 1px 0 rgba(255,255,255,0.02)';
    go.querySelector('.box').style.color = '#0ff';
    goTitle.style.textShadow = '0 0 10px #0ff, 0 0 30px #0ff';
  } else {
    go.style.display = 'flex'; go.querySelector('.box').style.background = 'rgba(0,0,0,0.75)';
    go.querySelector('.box').style.color = '#fff'; goTitle.style.textShadow = 'none';
  }
  goTitle.innerText = isBomb ? 'Boom! Bomb Kat Gaya' : 'Game Over';
  finalScore.innerText = 'Your Score: ' + score;
  bestScore.innerText = 'Best: ' + best;
}

replayBtn.addEventListener('click', ()=> { startGame(); });
homeBtn.addEventListener('click', ()=> { gameOverDiv.style.display = 'none'; homeOverlay.style.display = 'flex'; });

// start/how buttons
startBtn.addEventListener('click', ()=> startGame());
howBtn.addEventListener('click', ()=> alert('Swipe the screen (finger or mouse) to slice fruits. Bomb (üí£) will end the game. Slice multiple fruits in one swipe for combo bonus!'));

/* ===== initial settings ===== */
(function init(){
  // ensure canvas sized then show home
  resize();
  homeOverlay.style.display = 'flex';
  // load best score
  const best = localStorage.getItem('cutFruitHighScore') || '0';
  document.getElementById('bestScore').innerText = 'Best: ' + best;
})();

/* ===== small aesthetic: spawn small decorative fruits on body background ===== */
(function decor(){
  const emojis = FRUITS;
  setInterval(()=> {
    const el = document.createElement('div');
    el.style.position='absolute'; el.style.left = Math.random()*90+'vw'; el.style.top='-6vh';
    el.style.fontSize = (14+Math.random()*20)+'px'; el.style.opacity = 0.9;
    el.innerText = emojis[Math.floor(Math.random()*emojis.length)];
    document.body.appendChild(el);
    setTimeout(()=> { el.style.transition = 'top 6s linear, transform 6s linear'; el.style.top='110vh'; el.style.transform = 'rotate(360deg)'; }, 40);
    setTimeout(()=> el.remove(), 7000);
  }, 800);
})();

</script>
</body>
</html><!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cut Fruit ‚Äî Fruit Ninja Style</title>
<style>
  /* ‡§¨‡•á‡§∏‡§ø‡§ï ‡§∏‡•ç‡§ü‡§æ‡§á‡§≤ */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: linear-gradient(180deg,#0b1020,#061022);
    color:#fff;
    display:flex;align-items:center;justify-content:center;
    padding:12px;
  }

  /* ‡§ï‡§Ç‡§ü‡•á‡§®‡§∞ */
  .wrap{
    width:100%;max-width:980px;height:calc(100vh - 24px);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;position:relative;overflow:hidden;
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  }

  /* HUD */
  .hud{position:absolute;top:10px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:60}
  .panel{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,0.04);font-weight:700}
  .title{font-size:20px;color:#ffb6b6}
  .small{font-size:14px;color:#dbeafe}

  /* Home overlay */
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:70}
  .home{flex-direction:column;gap:12px;text-align:center;padding:20px}
  .btn{padding:12px 28px;border-radius:999px;border:2px solid rgba(255,120,120,0.9);background:transparent;color:#fff;cursor:pointer;font-weight:800}
  .btn:hover{background:rgba(255,120,120,0.12)}
  .credit{position:absolute;left:12px;bottom:8px;font-size:13px;color:#ddd}

  /* canvas */
  #gameCanvas{position:absolute;left:8px;right:8px;top:64px;bottom:12px;border-radius:10px;background:#000;touch-action:none;z-index:10;}

  /* gameover styles */
  .gameOver{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:100}
  .gameOver .box{background:rgba(0,0,0,0.75);padding:22px;border-radius:12px;text-align:center}
  .gameOver h2{margin-bottom:8px}
  .controls{display:flex;gap:10px;justify-content:center;margin-top:10px}

  /* small screens */
  @media (max-width:520px){
    .title{font-size:16px}
    .btn{padding:10px 18px}
  }
</style>
</head>
<body>

<div class="wrap" id="wrap">
  <div class="hud">
    <div style="display:flex;gap:10px;align-items:center">
      <div class="panel title">üçâ Cut Fruit</div>
      <div class="panel small" id="comboPanel">Combo: 0</div>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <div class="panel small" id="scorePanel">Score: 0</div>
      <div class="panel small" id="timePanel">Time: 60</div>
    </div>
  </div>

  <!-- Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- Home overlay -->
  <div class="overlay home" id="homeOverlay">
    <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
      <div style="font-size:48px;color:#ff8a8a">üçì Cut Fruit</div>
      <div style="color:#dbeafe">Fruit Ninja ‡§ú‡•à‡§∏‡§æ ‡§Ö‡§®‡•Å‡§≠‡§µ ‚Äî swipe ‡§ï‡§∞‡•ã ‡§î‡§∞ ‡§∏‡§≠‡•Ä ‡§´‡§≤ ‡§ï‡§æ‡§ü‡•ã!</div>
    </div>
    <div style="display:flex;gap:10px;margin-top:12px">
      <button class="btn" id="startBtn">‚ñ∂ Start</button>
      <button class="btn" id="howBtn">‚ùî How</button>
    </div>
    <div style="margin-top:10px;color:#d0e8ff">Choose Game Over Style:
      <select id="styleChoice" style="margin-left:8px;padding:6px;border-radius:8px">
        <option value="simple">Simple</option>
        <option value="neon">Neon</option>
      </select>
    </div>
    <div class="credit">Made by Arun Dhakad</div>
  </div>

  <!-- Game Over -->
  <div class="gameOver" id="gameOver">
    <div class="box" id="gameOverBox">
      <h2 id="goTitle">Game Over</h2>
      <div id="finalScore" style="font-weight:800;font-size:18px;margin-bottom:6px"></div>
      <div id="bestScore" style="margin-bottom:8px;color:#cfeaff"></div>
      <div class="controls">
        <button class="btn" id="replayBtn">üîÑ Replay</button>
        <button class="btn" id="homeBtn">üè† Home</button>
      </div>
    </div>
  </div>
</div>

<!-- Audio (base64 small sounds) -->
<audio id="sliceAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
<audio id="bombAudio" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>

<script>
/* ======= Fruit Ninja-like Game (Hindi comments) ======= */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('wrap');

// UI
const homeOverlay = document.getElementById('homeOverlay');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
const scorePanel = document.getElementById('scorePanel');
const timePanel = document.getElementById('timePanel');
const comboPanel = document.getElementById('comboPanel');
const gameOverDiv = document.getElementById('gameOver');
const goTitle = document.getElementById('goTitle');
const finalScore = document.getElementById('finalScore');
const bestScore = document.getElementById('bestScore');
const replayBtn = document.getElementById('replayBtn');
const homeBtn = document.getElementById('homeBtn');
const styleChoice = document.getElementById('styleChoice');

// sounds (placeholders small silent; you can replace with real base64 sounds)
const sliceAudio = document.getElementById('sliceAudio');
const bombAudio = document.getElementById('bombAudio');

// resize canvas to wrap area leaving HUD (top 64px)
function resize(){
  const r = wrap.getBoundingClientRect();
  canvas.width = Math.floor(r.width - 16);
  canvas.height = Math.floor(r.height - 86);
}
window.addEventListener('resize', resize);
resize();

// game state
let fruits = [];    // fruits & powerups
let pieces = [];    // sliced halves
let particles = []; // juice particles
let sliceTrails = []; // persistent slice lines
let score = 0;
let combo = 0;
let comboTimer = 0;
let remaining = 60;
let timerInterval = null;
let playing = false;
let lastTime = 0;
let spawnAccumulator = 0;
let pointerDown = false;
let tracks = []; // swipe track points
let swipePath = []; // visible trail
let slowUntil = 0; // slow motion timestamp

// emoji sets
const FRUITS = ["üçé","üçä","üçå","üçâ","üçì","üçë"];
const POWERS = ["üí£","‚è±Ô∏è","üçÄ"]; // bomb, time-freeze, slice-all

// random helper
const rand = (a,b)=> a + Math.random()*(b-a);

// Fruit class
class Fruit {
  constructor(type='fruit'){
    this.x = rand(60, canvas.width-60);
    this.y = canvas.height + 40;
    this.r = rand(26,36);
    this.vx = rand(-3.5,3.5);
    this.vy = rand(13,18); // upward
    this.gravity = 0.45;
    this.angle = rand(0,Math.PI*2);
    this.angular = rand(-0.18,0.18);
    this.type = type; // 'fruit' or 'power'
    this.emoji = (this.type==='fruit') ? FRUITS[Math.floor(rand(0,FRUITS.length))] : POWERS[Math.floor(rand(0,POWERS.length))];
    this.alive = true;
    this.spawn = Date.now();
  }
  update(dt){
    const slow = Date.now() < slowUntil ? 0.45 : 1;
    this.x += this.vx * (dt/16) * slow;
    this.y -= this.vy * (dt/16) * slow;
    this.vy -= this.gravity * (dt/16) * slow;
    this.angle += this.angular * (dt/16) * slow;
    if(this.y > canvas.height + 80) this.alive = false;
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.font = `${this.r*2}px serif`;
    ctx.textAlign = 'center';
    ctx.fillText(this.emoji, 0, 0);
    ctx.restore();
  }
}

// spawn multiple fruits at once (1-4)
function spawnWave(){
  const count = Math.floor(rand(1,4)); // 1 to 3
  for(let i=0;i<count;i++){
    if(Math.random() < 0.12) fruits.push(new Fruit('power'));
    else fruits.push(new Fruit('fruit'));
  }
}

// slice effects
function addSliceTrail(x1,y1,x2,y2){
  sliceTrails.push({x1,y1,x2,y2,ttl:360,alpha:1});
}

// particles (juice)
function spawnParticles(x,y,emoji){
  const c = (emoji==='üçì' || emoji==='üçé') ? 'rgba(255,90,110,0.95)' : 'rgba(255,200,80,0.95)';
  for(let i=0;i<14;i++){
    particles.push({
      x: x + rand(-8,8),
      y: y + rand(-8,8),
      vx: rand(-6,6),
      vy: rand(2,10),
      life: 300 + rand(0,300),
      c: c,
      size: rand(3,7)
    });
  }
}

// when fruit sliced
function sliceFruitAt(index, mx, my){
  const f = fruits[index];
  if(!f) return;
  // powerups handling
  if(f.type === 'power'){
    if(f.emoji === 'üí£'){
      // bomb -> explosion and game over
      for(let i=0;i<28;i++) particles.push({
        x:f.x,y:f.y,vx:rand(-8,8),vy:rand(-2,10),life:300+rand(0,300),c:'rgba(255,200,60,0.95)',size:rand(4,8)
      });
      bombAudio.currentTime = 0; try{ bombAudio.play(); }catch(e){}
      endGame(true);
      return;
    } else if(f.emoji === '‚è±Ô∏è'){
      slowUntil = Date.now() + 4500;
      score += 12;
      combo++; comboTimer = Date.now();
      fruits.splice(index,1);
      refreshUI();
      sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
      return;
    } else if(f.emoji === 'üçÄ'){
      // slice all: score all fruits
      score += fruits.length * 10;
      spawnParticles(f.x,f.y,'üçÄ');
      fruits = [];
      combo++; comboTimer = Date.now();
      refreshUI();
      sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
      return;
    }
  }

  // normal fruit -> create two pieces & particles
  pieces.push({x:f.x-8,y:f.y,vx:-rand(2,6),vy:rand(6,12),ang:rand(-0.3,0.3),emoji:f.emoji,life:800});
  pieces.push({x:f.x+8,y:f.y,vx:rand(2,6),vy:rand(6,12),ang:rand(-0.3,0.3),emoji:f.emoji,life:800});
  spawnParticles(f.x,f.y,f.emoji);
  addSliceTrail(mx-30,my-10,mx+30,my+10);
  score += 10;
  combo++; comboTimer = Date.now();
  fruits.splice(index,1);
  sliceAudio.currentTime = 0; try{ sliceAudio.play(); }catch(e){}
  refreshUI();
}

// UI update
function refreshUI(){
  scorePanel.innerText = 'Score: ' + score;
  comboPanel.innerText = 'Combo: ' + (combo>0?combo:0);
}

// slow motion helper
function slowMotion(ms){ slowUntil = Date.now() + ms; }

// handle swipe segment collision with fruits
function handleSegment(p1,p2){
  let slicedCount = 0;
  for(let i = fruits.length-1; i >= 0; i--){
    const f = fruits[i];
    // distance from point to segment
    const px = f.x, py = f.y;
    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
    const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if(len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if(param < 0){ xx = x1; yy = y1; }
    else if(param > 1){ xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx, dy = py - yy;
    const d = Math.sqrt(dx*dx + dy*dy);
    if(d < f.r * 0.85){
      const mx = (x1 + x2)/2, my = (y1 + y2)/2;
      sliceFruitAt(i, mx, my);
      slicedCount++;
    }
  }
  // combo bonus if multiple in same segment
  if(slicedCount >= 2){
    const bonus = slicedCount * 5;
    score += bonus;
    refreshUI();
  }
  return slicedCount;
}

/* ===== Input handling (touch & mouse) ===== */
canvas.addEventListener('mousedown', e=>{
  if(!playing) return;
  const r = canvas.getBoundingClientRect();
  pointerDown = true;
  tracks = [{x:e.clientX - r.left, y: e.clientY - r.top, t:Date.now()}];
  swipePath = [{x:e.clientX - r.left, y: e.clientY - r.top}];
});
window.addEventListener('mousemove', e=>{
  if(!playing || !pointerDown) return;
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;
  tracks.push({x,y,t:Date.now()});
  if(tracks.length > 30) tracks.shift();
  swipePath.push({x,y}); if(swipePath.length>30) swipePath.shift();
  // check only last segment
  if(tracks.length > 1) handleSegment(tracks[tracks.length-2], tracks[tracks.length-1]);
});
window.addEventListener('mouseup', e=>{
  if(!playing) return;
  pointerDown = false;
  tracks = [];
  setTimeout(()=> swipePath = [], 120);
});

canvas.addEventListener('touchstart', e=>{
  if(!playing) return;
  const t = e.touches[0]; const r = canvas.getBoundingClientRect();
  pointerDown = true;
  tracks = [{x:t.clientX - r.left, y: t.clientY - r.top, t:Date.now()}];
  swipePath = [{x:t.clientX - r.left, y: t.clientY - r.top}];
});
canvas.addEventListener('touchmove', e=>{
  if(!playing || !pointerDown) return;
  const t = e.touches[0]; const r = canvas.getBoundingClientRect();
  const x = t.clientX - r.left, y = t.clientY - r.top;
  tracks.push({x,y,t:Date.now()});
  if(tracks.length > 30) tracks.shift();
  swipePath.push({x,y}); if(swipePath.length>30) swipePath.shift();
  if(tracks.length > 1) handleSegment(tracks[tracks.length-2], tracks[tracks.length-1]);
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  if(!playing) return;
  pointerDown = false;
  tracks = [];
  setTimeout(()=> swipePath = [], 120);
});

/* ===== pieces & particles update/draw ===== */
function updatePieces(dt){
  for(let i=pieces.length-1;i>=0;i--){
    const p = pieces[i];
    p.x += p.vx * (dt/16);
    p.y -= p.vy * (dt/16);
    p.vy -= 0.4 * (dt/16);
    p.ang += 0.03 * (dt/16);
    p.life -= dt;
    if(p.life <= 0) pieces.splice(i,1);
  }
}
function drawPieces(ctx){
  for(const p of pieces){
    ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.ang); ctx.font='28px serif'; ctx.textAlign='center'; ctx.fillText(p.emoji,0,0); ctx.restore();
  }
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx * (dt/16);
    p.y -= p.vy * (dt/16);
    p.vy -= 0.2 * (dt/16);
    p.life -= dt;
    if(p.life <= 0) particles.splice(i,1);
  }
}
function drawParticles(ctx){
  for(const p of particles){
    ctx.save(); ctx.globalAlpha = Math.max(0, p.life/600); ctx.fillStyle = p.c; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
}

/* ===== slice trails draw & update ===== */
function drawSwipeTrail(ctx){
  if(swipePath.length < 2) return;
  ctx.save(); ctx.lineJoin = ctx.lineCap = 'round';
  // main white trail
  ctx.globalAlpha = 0.9; ctx.lineWidth = 8;
  const g = ctx.createLinearGradient(swipePath[0].x, swipePath[0].y, swipePath[swipePath.length-1].x, swipePath[swipePath.length-1].y);
  g.addColorStop(0, 'rgba(255,255,255,0.95)'); g.addColorStop(1, 'rgba(0,200,255,0.4)');
  ctx.strokeStyle = g; ctx.beginPath();
  for(let i=0;i<swipePath.length;i++){ const p=swipePath[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
  ctx.stroke();
  // faint secondary
  ctx.lineWidth = 3; ctx.globalAlpha = 0.25; ctx.strokeStyle = 'rgba(0,200,255,0.6)'; ctx.beginPath();
  for(let i=0;i<swipePath.length;i++){ const p=swipePath[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }
  ctx.stroke();
  ctx.restore();
}
function updateSliceTrails(dt){
  for(let i=sliceTrails.length-1;i>=0;i--){
    const s = sliceTrails[i];
    s.ttl -= dt; s.alpha = Math.max(0, s.ttl/360);
    if(s.ttl <= 0) sliceTrails.splice(i,1);
  }
}
function drawSliceTrails(ctx){
  for(const s of sliceTrails){
    ctx.save();
    ctx.lineWidth = 6; ctx.strokeStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.shadowBlur = 10; ctx.shadowColor = 'white';
    ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
    ctx.restore();
  }
}

/* ===== main loop ===== */
function gameLoop(now){
  if(!playing) return;
  if(!lastTime) lastTime = now;
  const dt = now - lastTime; lastTime = now;

  // spawn logic: faster if not slow
  spawnAccumulator += dt;
  const spawnInterval = (Date.now() < slowUntil) ? 700*1.6 : 700;
  if(spawnAccumulator > spawnInterval){
    spawnAccumulator = 0;
    // spawn a wave
    spawnWave();
  }

  // update entities
  for(const f of fruits) f.update(dt);
  updatePieces(dt);
  updateParticles(dt);
  updateSliceTrails(dt);

  // remove dead fruits
  fruits = fruits.filter(f => f.alive);

  // combo reset & small bonus when combo finishes
  if(combo>0 && Date.now() - comboTimer > 900){
    if(combo >= 2){ score += combo * 5; refreshUI(); }
    combo = 0; comboPanel.innerText = 'Combo: 0';
  }

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const f of fruits) f.draw(ctx);
  drawPieces(ctx);
  drawParticles(ctx);
  drawSliceTrails(ctx);
  drawSwipeTrail(ctx);

  requestAnimationFrame(gameLoop);
}

/* ===== game control functions ===== */
function refreshPanels(){
  scorePanel.innerText = 'Score: ' + score;
  timePanel.innerText = 'Time: ' + remaining;
  comboPanel.innerText = 'Combo: ' + (combo>0?combo:0);
}

function startGame(){
  // reset
  fruits = []; pieces = []; particles = []; sliceTrails = [];
  score = 0; combo = 0; comboTimer = 0; remaining = 60; refreshPanels();
  homeOverlay.style.display = 'none';
  gameOverDiv.style.display = 'none';
  playing = true; lastTime = 0; spawnAccumulator = 0;
  // start timer
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    if(!playing) return;
    remaining--; timePanel.innerText = 'Time: ' + remaining;
    if(remaining <= 0) endGame(false);
  }, 1000);
  requestAnimationFrame(gameLoop);
}
function endGame(isBomb=false){
  playing = false;
  if(timerInterval) clearInterval(timerInterval);
  // update high score
  let best = parseInt(localStorage.getItem('cutFruitHighScore') || '0', 10);
  if(score > best){ best = score; localStorage.setItem('cutFruitHighScore', best); }
  // show Game Over with chosen style
  const style = styleChoice.value || 'simple';
  const go = document.getElementById('gameOver');
  const box = document.getElementById('gameOverBox');
  // apply styles
  if(style === 'neon'){
    go.style.display = 'flex'; go.querySelector('.box').style.background = 'linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4))';
    go.querySelector('.box').style.boxShadow = '0 8px 40px rgba(0,255,255,0.06), inset 0 1px 0 rgba(255,255,255,0.02)';
    go.querySelector('.box').style.color = '#0ff';
    goTitle.style.textShadow = '0 0 10px #0ff, 0 0 30px #0ff';
  } else {
    go.style.display = 'flex'; go.querySelector('.box').style.background = 'rgba(0,0,0,0.75)';
    go.querySelector('.box').style.color = '#fff'; goTitle.style.textShadow = 'none';
  }
  goTitle.innerText = isBomb ? 'Boom! Bomb Kat Gaya' : 'Game Over';
  finalScore.innerText = 'Your Score: ' + score;
  bestScore.innerText = 'Best: ' + best;
}

replayBtn.addEventListener('click', ()=> { startGame(); });
homeBtn.addEventListener('click', ()=> { gameOverDiv.style.display = 'none'; homeOverlay.style.display = 'flex'; });

// start/how buttons
startBtn.addEventListener('click', ()=> startGame());
howBtn.addEventListener('click', ()=> alert('Swipe the screen (finger or mouse) to slice fruits. Bomb (üí£) will end the game. Slice multiple fruits in one swipe for combo bonus!'));

/* ===== initial settings ===== */
(function init(){
  // ensure canvas sized then show home
  resize();
  homeOverlay.style.display = 'flex';
  // load best score
  const best = localStorage.getItem('cutFruitHighScore') || '0';
  document.getElementById('bestScore').innerText = 'Best: ' + best;
})();

/* ===== small aesthetic: spawn small decorative fruits on body background ===== */
(function decor(){
  const emojis = FRUITS;
  setInterval(()=> {
    const el = document.createElement('div');
    el.style.position='absolute'; el.style.left = Math.random()*90+'vw'; el.style.top='-6vh';
    el.style.fontSize = (14+Math.random()*20)+'px'; el.style.opacity = 0.9;
    el.innerText = emojis[Math.floor(Math.random()*emojis.length)];
    document.body.appendChild(el);
    setTimeout(()=> { el.style.transition = 'top 6s linear, transform 6s linear'; el.style.top='110vh'; el.style.transform = 'rotate(360deg)'; }, 40);
    setTimeout(()=> el.remove(), 7000);
  }, 800);
})();

</script>
</body>
</html>
