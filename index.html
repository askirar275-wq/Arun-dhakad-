<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Fruit Cut ‚Äî Images Mode</title>
<style>
  :root{ --accent:#00ffd5; --danger:#ff6b6b; }
  html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:Inter,system-ui,Arial;overflow:hidden}
  #game-wrap{position:relative;display:grid;height:100%;grid-template-rows:1fr auto}
  #bg{position:absolute;inset:0;z-index:0;background:#081023}
  canvas{position:relative;z-index:1;display:block;width:100%;height:100%}
  #ui{position:relative;z-index:2;padding:10px;display:flex;gap:8px;align-items:center;justify-content:space-between;background:rgba(0,0,0,0.22);backdrop-filter:blur(4px)}
  .btn{--bd:2px;padding:8px 12px;border-radius:10px;cursor:pointer;outline:none;color:var(--accent);background:transparent;border:var(--bd) solid rgba(0,255,213,.14);font-weight:800;box-shadow:0 8px 26px rgba(0,0,0,.45)}
  .btn:hover{transform:translateY(-3px)}
  .btn.small{padding:7px 10px;font-size:13px}
  .pill{background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06)}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;background:rgba(0,0,0,.86);color:#fff;padding:8px 14px;border-radius:999px;display:none;z-index:6}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:8;background:rgba(0,0,0,.45)}
  #loaderCard{min-width:260px;padding:18px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.18));border:1px solid rgba(255,255,255,.06);text-align:center}
  #hitFlash{position:fixed;inset:0;background:radial-gradient(120% 120% at 50% 40%, rgba(255,80,80,.25), rgba(0,0,0,0));pointer-events:none;opacity:0;transition:opacity .12s;z-index:4}
  #hitFlash.show{opacity:1}
</style>
</head>
<body>
  <div id="game-wrap">
    <div id="bg"></div>
    <canvas id="c"></canvas>

    <div id="ui">
      <div style="display:flex;gap:8px;align-items:center">
        <div id="score" class="pill">Score: 0</div>
        <div id="combo" class="pill">Combo: x1</div>
        <div id="lives" class="pill">Lives: 3</div>
        <div id="themeName" class="pill">Theme: Neon</div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="devBtn" class="btn small">Dev Console</button>
        <button id="imagesToggle" class="btn small">Use Images: OFF</button>
        <button id="themeBtn" class="btn small">Change Theme</button>
        <button id="boardBtn" class="btn small">Leaderboard</button>
        <button id="pauseBtn" class="btn small">Pause</button>
        <button id="restartBtn" class="btn small">Restart</button>
      </div>
    </div>
  </div>

  <!-- Loader -->
  <div id="loader" class="overlay" style="display:flex">
    <div id="loaderCard">
      <div id="loaderText">Loading images...</div>
      <div style="height:10px;margin-top:12px;background:#0b1220;border-radius:999px;overflow:hidden">
        <div id="loaderFill" style="height:100%;width:0;background:linear-gradient(90deg,var(--accent),#06b6d4);transition:width .25s"></div>
      </div>
      <div id="loaderCount" style="margin-top:8px;font-size:13px;color:#cfe">0 / 0</div>
      <div style="margin-top:10px;font-size:13px;color:#cfe">Put images into <code>images/</code> folder with correct filenames.</div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="boardModal" class="overlay" style="display:none;align-items:center;justify-content:center">
    <div style="min-width:280px;padding:16px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(0,0,0,.16));border:1px solid rgba(255,255,255,.06)">
      <h3 style="margin:0 0 8px">üèÜ Leaderboard</h3>
      <ol id="boardList" style="padding-left:18px;margin:6px 0 0"></ol>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button id="resetBoard" class="btn small" style="background:rgba(255,80,80,.08);border-color:rgba(255,80,80,.18)">Reset</button>
        <button id="closeBoard" class="btn small">Close</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>
  <div id="hitFlash"></div>

<script>
/* Fruit Cut ‚Äî Image assets support + Eruda + Smooth build
   Place image files as specified in IMAGE_ASSETS. If some images fail, emoji fallback used.
*/

/* ---------- CONFIG: filenames to load from images/ folder ---------- */
const IMAGE_ASSETS = {
  fruits: [
    {name:'apple', file:'images/apple.png', emoji:'üçé'},
    {name:'banana',file:'images/banana.png', emoji:'üçå'},
    {name:'orange',file:'images/orange.png', emoji:'üçä'},
    {name:'pear',  file:'images/pear.png',   emoji:'üçê'},
    {name:'grapes',file:'images/grapes.png', emoji:'üçá'},
    {name:'straw', file:'images/strawberry.png', emoji:'üçì'},
    {name:'kiwi',  file:'images/kiwi.png',    emoji:'ü•ù'}
  ],
  bomb: {name:'bomb', file:'images/bomb.png', emoji:'üí£'},
  powerups: [
    {name:'slow', file:'images/slow.png', emoji:'üê¢'},
    {name:'double', file:'images/double.png', emoji:'‚ú®'},
    {name:'shield', file:'images/shield.png', emoji:'üõ°Ô∏è'}
  ]
};

/* ---------- Theme (same as before) ---------- */
const THEMES = [
  { id:'neon',   name:'Neon',   css:'radial-gradient(120% 120% at 50% 15%, #0e1626 0%, #08121d 60%, #050b12 100%)' },
  { id:'sunset', name:'Sunset', css:'linear-gradient(180deg,#22122d 0%, #3b1531 55%, #1b0f1a 100%)' },
  { id:'ocean',  name:'Ocean',  css:'linear-gradient(180deg,#051b2a 0%, #093247 55%, #061b28 100%)' },
];
const woodSVG = encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 256 256'><defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='#7b5a2b' stop-opacity='0.18'/><stop offset='100%' stop-color='#4e351a' stop-opacity='0.18'/></linearGradient></defs><rect width='256' height='256' fill='url(#g)'/><g fill='none' stroke='#3a2813' stroke-opacity='.25' stroke-width='4'><path d='M0,40 C60,20 120,60 180,40 C220,28 250,38 256,36'/><path d='M0,100 C60,80 120,120 180,100 C220,88 250,98 256,96'/><path d='M0,160 C60,140 120,180 180,160 C220,148 250,158 256,156'/><path d='M0,220 C60,200 120,240 180,220 C220,208 250,218 256,216'/></g><g fill='#3a2813' fill-opacity='.28'><circle cx='42' cy='88' r='6'/><circle cx='210' cy='190' r='5'/></g></svg>`);
THEMES.push({ id:'wood', name:'Wood', css:`url("data:image/svg+xml;utf8,${woodSVG}") repeat, radial-gradient(120% 120% at 50% 15%, #1a1712 0%, #13110e 60%, #0d0c0a 100%)` });

/* ---------- Leaderboard helpers ---------- */
const BOARD_KEY = 'fc_images_top5_v1';
function loadBoard(){ try{ return JSON.parse(localStorage.getItem(BOARD_KEY)||'[]'); }catch(e){ return []; } }
function saveBoard(list){ localStorage.setItem(BOARD_KEY, JSON.stringify(list.slice(0,5))); }
function addScore(sc){ const list=loadBoard(); list.push({score:sc, ts:Date.now()}); list.sort((a,b)=>b.score-a.score); saveBoard(list); }
function renderBoard(){ const list=loadBoard(); const container=document.getElementById('boardList'); container.innerHTML=''; if(!list.length){ container.innerHTML='<li style="justify-content:center">No scores yet</li>'; return; } list.slice(0,5).forEach((it,i)=>{ const d=new Date(it.ts); const li=document.createElement('li'); li.style.display='flex'; li.style.justifyContent='space-between'; li.style.gap='10px'; li.style.padding='8px'; li.style.borderRadius='8px'; li.style.background='rgba(255,255,255,.02)'; li.innerHTML = `<span>${i+1}. ${it.score}</span><span style="color:#cfe">${d.getDate().toString().padStart(2,'0')}/${(d.getMonth()+1).toString().padStart(2,'0')}</span>`; container.appendChild(li); }); }

/* ---------- Canvas & Game configuration ---------- */
const cfg = {
  width: 900, height: 1600, viewW:900, viewH:1600,
  gravity: 1100, spawnInterval: 1.0, difficultyRamp: 0.992,
  maxFruits: 36, maxParticles: 200, trailLength: 12,
  comboResetTime: 1.6, powerupChance: 0.05
};
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
const bgLayer = document.getElementById('bg');

/* ---------- Responsive sizing ---------- */
function resize(){ const r = window.devicePixelRatio||1; const uiH = document.getElementById('ui')?.offsetHeight || 60; const cssW = Math.min(window.innerWidth, cfg.width); const cssH = Math.min(window.innerHeight - uiH, cfg.height); canvas.width = Math.floor(cssW * r); canvas.height = Math.floor(cssH * r); canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px'; ctx.setTransform(r,0,0,r,0,0); cfg.viewW = cssW; cfg.viewH = cssH; } window.addEventListener('resize', resize); resize();

/* ---------- Pools ---------- */
function Pool(createFn, size){ this.pool=[]; for(let i=0;i<size;i++) this.pool.push(createFn()); }
Pool.prototype.get=function(){ return this.pool.length?this.pool.pop():null; }
Pool.prototype.release=function(o){ if(o.reset) o.reset(); this.pool.push(o); }

/* ---------- Entities ---------- */
class Fruit {
  constructor(){ this.reset(); }
  reset(){ this.alive=false; this.x=0;this.y=0;this.vx=0;this.vy=0;this.radius=36;this.type='fruit';this.img=null;this.emoji='üçé';this.rotation=0;this.spin=0; }
  init(opts){ Object.assign(this, opts); this.alive=true; }
  update(dt){ this.vy += cfg.gravity * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.rotation += this.spin * dt; if(this.y - this.radius > cfg.viewH + 100) this.alive=false; }
  draw(ctx, useImages){
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.rotation);
    if(useImages && this.img && this.img.complete){
      // drawImage centered, scale to diameter
      const d = this.radius*2;
      ctx.drawImage(this.img, -d/2, -d/2, d, d);
    } else {
      ctx.font = `${this.radius*1.6}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.emoji, 0, 0);
    }
    ctx.restore();
  }
}
class Particle {
  constructor(){ this.reset(); }
  reset(){ this.alive=false; this.x=0;this.y=0;this.vx=0;this.vy=0;this.life=0;this.l=0;this.size=2; }
  init(x,y,vx,vy,life,size){ this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.life=life;this.l=life;this.size=size; this.alive=true; }
  update(dt){ this.vy += 360 * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; if(this.life <= 0) this.alive=false; }
  draw(ctx){ ctx.globalAlpha = Math.max(0, this.life / this.l); ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; }
}

/* ---------- Pools instances ---------- */
const fruitPool = new Pool(()=>new Fruit(), cfg.maxFruits);
const particlePool = new Pool(()=>new Particle(), cfg.maxParticles);

/* ---------- State ---------- */
let fruits = [], particles = [];
let score = 0, combo = 0, comboTimer = 0, lives = 3;
let lastSpawn = 0, spawnInterval = cfg.spawnInterval, wave = 1;
let running = true, paused = false;
let lastTime = performance.now()/1000;
let powerups = [], slowTimer = 0, doubleTimer = 0, lifeCooldown = 0;

let useImages = false; // toggled by UI
const images = { fruits: {}, bomb: null, powerups: {} };

/* ---------- Preload images from IMAGE_ASSETS ---------- */
const loader = document.getElementById('loader');
const loaderFill = document.getElementById('loaderFill');
const loaderCount = document.getElementById('loaderCount');

async function preloadAll(){
  const toLoad = [];
  IMAGE_ASSETS.fruits.forEach(f => toLoad.push({type:'fruit', key:f.name, file:f.file, emoji:f.emoji}));
  toLoad.push({type:'bomb', key:'bomb', file:IMAGE_ASSETS.bomb.file, emoji:IMAGE_ASSETS.bomb.emoji});
  IMAGE_ASSETS.powerups.forEach(p => toLoad.push({type:'power', key:p.name, file:p.file, emoji:p.emoji}));

  loader.style.display = 'flex';
  loaderCount.textContent = `0 / ${toLoad.length}`;
  loaderFill.style.width = '0%';

  let loadedCount = 0;
  function mark(){
    loadedCount++;
    loaderCount.textContent = `${loadedCount} / ${toLoad.length}`;
    loaderFill.style.width = `${Math.round(loadedCount / toLoad.length * 100)}%`;
  }

  // load sequentially (so user sees progress)
  for(const item of toLoad){
    try{
      const img = await loadImage(item.file);
      if(item.type === 'fruit') images.fruits[item.key] = img;
      else if(item.type === 'bomb') images.bomb = img;
      else if(item.type === 'power') images.powerups[item.key] = img;
    }catch(err){
      // store null to indicate fallback to emoji
      if(item.type === 'fruit') images.fruits[item.key] = null;
      else if(item.type === 'bomb') images.bomb = null;
      else if(item.type === 'power') images.powerups[item.key] = null;
      console.warn('Image failed:', item.file, err);
    }
    mark();
  }

  // hide loader
  setTimeout(()=>{ loader.style.display = 'none'; }, 350);
}

function loadImage(src){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error('Failed to load ' + src));
    img.src = src;
    // cache-busting avoided to let local files be used
  });
}

/* ---------- Spawn helpers (use same patterns as before) ---------- */
function rand(a,b){ return a + Math.random()*(b-a); }
function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function spawnOne(x,y,vx,vy,opts={}){
  const f = fruitPool.get(); if(!f) return;
  const isBomb = Math.random() < 0.06;
  if(isBomb){
    const img = images.bomb;
    f.init({
      x,y,vx,vy,
      radius: rand(30,48),
      emoji: IMAGE_ASSETS.bomb.emoji,
      img: img,
      type: 'bomb',
      spin: rand(-4,4)
    });
  } else {
    // choose fruit entry and attach the preloaded image
    const entry = IMAGE_ASSETS.fruits[(Math.random()*IMAGE_ASSETS.fruits.length)|0];
    const img = images.fruits[entry.name] ?? null;
    f.init({
      x,y,vx,vy,
      radius: rand(28,42),
      emoji: entry.emoji,
      img: img,
      type: 'fruit',
      spin: rand(-4,4)
    });
  }
  fruits.push(f);
}

function spawnSingle(){ spawnOne(rand(120,cfg.viewW-120), cfg.viewH+60, rand(-200,200), -rand(700,1100)); }
function spawnBomb(){ spawnOne(rand(120,cfg.viewW-120), cfg.viewH+60, rand(-180,180), -rand(700,1050)); }

function spawnArc(n){
  const cx = rand(200,cfg.viewW-200);
  for(let i=0;i<n;i++){
    const ang = Math.PI*(0.25 + i/(n-1)*0.5);
    const s = rand(700,1050); const vx = Math.cos(ang-1.2)*s; const vy = -Math.sin(ang-1.2)*s;
    spawnOne(cx + (i-n/2)*28, cfg.viewH+60, vx, vy);
  }
}
function spawnFan(n){
  const left = rand(120, Math.max(160, cfg.viewW-360));
  for(let i=0;i<n;i++) spawnOne(left + i*36, cfg.viewH+60, rand(-140,340), -rand(650,1050));
}
function spawnChain(n){
  const x = rand(160, cfg.viewW-160);
  for(let i=0;i<n;i++) spawnOne(x + Math.sin(i*0.55)*36, cfg.viewH+60 + i*10, rand(-90,90), -rand(600,950) - i*18);
}
function spawnBurst(n){
  const cx = rand(200,cfg.viewW-200);
  for(let i=0;i<n;i++){ const a=rand(0,Math.PI*2), s=rand(380,980); spawnOne(cx+Math.cos(a)*10, cfg.viewH+60 + Math.sin(a)*10, Math.cos(a)*s, -Math.abs(Math.sin(a))*s); }
}
function spawnPowerup(){
  const choices = IMAGE_ASSETS.powerups;
  const entry = choices[(Math.random()*choices.length)|0];
  const f = fruitPool.get(); if(!f) return;
  const img = images.powerups[entry.name] ?? null;
  f.init({
    x: rand(160,cfg.viewW-160), y: cfg.viewH+60,
    vx: rand(-160,160), vy: -rand(700,1100),
    radius: 36, emoji: entry.emoji, img: img,
    type: 'power', power: entry.name, spin: rand(-4,4)
  });
  fruits.push(f);
}

/* ---------- Input & slicing ---------- */
let isPointerDown = false;
let pts = [];
const maxTrail = cfg.trailLength;
function addTrail(x,y){ pts.push({x,y}); if(pts.length>maxTrail) pts.shift(); }
function onDown(x,y){ isPointerDown=true; pts=[]; addTrail(x,y); }
function onMove(x,y){ if(isPointerDown) addTrail(x,y); }
function onUp(){ isPointerDown=false; checkSlicing(); pts=[]; }

canvas.addEventListener('mousedown', e => { const r = canvas.getBoundingClientRect(); onDown(e.clientX - r.left, e.clientY - r.top); });
window.addEventListener('mousemove', e => { if(!isPointerDown) return; const r = canvas.getBoundingClientRect(); onMove(e.clientX - r.left, e.clientY - r.top); });
window.addEventListener('mouseup', () => { if(!isPointerDown) return; onUp(); });

canvas.addEventListener('touchstart', e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const t = e.changedTouches[0]; onDown(t.clientX - r.left, t.clientY - r.top); }, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); if(!isPointerDown) return; const r = canvas.getBoundingClientRect(); const t = e.changedTouches[0]; onMove(t.clientX - r.left, t.clientY - r.top); }, {passive:false});
canvas.addEventListener('touchend', e => { e.preventDefault(); onUp(); }, {passive:false});

/* ---------- Utility functions ---------- */
function spawnParticle(x,y,vx,vy,life,size){ const p = particlePool.get(); if(!p) return; p.init(x,y,vx,vy,life,size); particles.push(p); }

/* ---------- Pools create functions ---------- */
function createFruit(){ return new Fruit(); }
function createParticle(){ return new Particle(); }

/* Recreate pools with updated sizes (in case) */
const poolFruit = fruitPool; // already created above
const poolParticle = particlePool;

/* ---------- Game logic: slicing, hits ---------- */
function checkSlicing(){
  if(pts.length < 2) return;
  for(let i=0;i<fruits.length;i++){
    const f = fruits[i];
    if(!f.alive) continue;
    for(let s=0;s<pts.length-1;s++){
      const a = pts[s], b = pts[s+1];
      const dx = b.x - a.x, dy = b.y - a.y, l2 = dx*dx + dy*dy + 1e-6;
      const t = ((f.x - a.x)*dx + (f.y - a.y)*dy) / l2;
      const clx = a.x + dx * Math.max(0, Math.min(1, t));
      const cly = a.y + dy * Math.max(0, Math.min(1, t));
      const d2 = (clx - f.x)*(clx - f.x) + (cly - f.y)*(cly - f.y);
      if(d2 <= f.radius * f.radius){
        handleHit(f, dx*dx + dy*dy);
        break;
      }
    }
  }
}

function handleHit(f, speedSq){
  if(!f.alive) return;
  if(f.type === 'bomb'){
    if(lifeCooldown <= 0){
      if(powerups.includes('shield')){ powerups = powerups.filter(p=>p!=='shield'); } 
      else {
        lives = Math.max(0, lives - 1);
        document.getElementById('hitFlash').classList.add('show');
        setTimeout(()=>document.getElementById('hitFlash').classList.remove('show'), 120);
        for(let i=0;i<28;i++) spawnParticle(f.x + rand(-12,12), f.y + rand(-12,12), rand(-600,600), rand(-600,600), rand(0.35,0.8), 3);
      }
      lifeCooldown = 0.45;
    }
    f.alive = false; fruitPool.release(f); fruits.splice(fruits.indexOf(f),1);
    return;
  }
  if(f.type === 'power'){
    if(f.power === 'slow') slowTimer = Math.max(slowTimer, 2.6);
    if(f.power === 'double') doubleTimer = Math.max(doubleTimer, 6.2);
    if(f.power === 'shield') powerups.push('shield'); else if(!powerups.includes(f.power)) powerups.push(f.power);
    showToast(f.power==='slow'?'SLOW!':f.power==='double'?'DOUBLE!':'SHIELD!');
    f.alive=false; fruitPool.release(f); fruits.splice(fruits.indexOf(f),1);
    return;
  }
  // normal fruit
  f.alive=false; fruitPool.release(f); fruits.splice(fruits.indexOf(f),1);
  for(let i=0;i<10;i++) spawnParticle(f.x + rand(-f.radius,f.radius), f.y + rand(-f.radius,f.radius), rand(-420,420), rand(-420,420), rand(0.35,0.9), rand(2,4));
  const base = 10;
  const speedBonus = Math.min(4, Math.sqrt(speedSq) / 90);
  combo += 1; comboTimer = cfg.comboResetTime;
  const mult = 1 + Math.floor(combo/5) * 0.5 + (doubleTimer > 0 ? 1 : 0);
  score += Math.round(base * mult * (1 + speedBonus * 0.2));
}

/* ---------- Spawn controller ---------- */
function spawnPattern(){
  const patterns = ['arc','fan','single','chain','burst'];
  const p = choose(patterns);
  const count = Math.min(5 + Math.floor(wave/2), 10);
  if(p==='single') spawnSingle();
  else if(p==='arc') spawnArc(count);
  else if(p==='fan') spawnFan(count);
  else if(p==='chain') spawnChain(count);
  else if(p==='burst') spawnBurst(count);
  if(Math.random() < 0.10) spawnBomb();
  if(Math.random() < cfg.powerupChance) spawnPowerup();
}

/* spawn helpers (reuse earlier ones) */
function spawnArc(n){
  const cx = rand(200, cfg.viewW-200);
  for(let i=0;i<n;i++){ const ang = Math.PI*(0.25 + i/(n-1)*0.5); const s=rand(700,1050); spawnOne(cx + (i-n/2)*28, cfg.viewH+60, Math.cos(ang-1.2)*s, -Math.sin(ang-1.2)*s); }
}
function spawnFan(n){ const left = rand(120, Math.max(160, cfg.viewW-360)); for(let i=0;i<n;i++) spawnOne(left + i*36, cfg.viewH+60, rand(-140,340), -rand(650,1050)); }
function spawnChain(n){ const x = rand(160, cfg.viewW-160); for(let i=0;i<n;i++) spawnOne(x + Math.sin(i*0.55)*36, cfg.viewH+60 + i*10, rand(-90,90), -rand(600,950) - i*18); }
function spawnBurst(n){ const cx = rand(200, cfg.viewW-200); for(let i=0;i<n;i++){ const a=rand(0,Math.PI*2), s=rand(380,980); spawnOne(cx+Math.cos(a)*10, cfg.viewH+60 + Math.sin(a)*10, Math.cos(a)*s, -Math.abs(Math.sin(a))*s); } }
function spawnPowerup(){ const entry = IMAGE_ASSETS.powerups[(Math.random()*IMAGE_ASSETS.powerups.length)|0]; const img = images.powerups[entry.name] ?? null; const f = fruitPool.get(); if(!f) return; f.init({ x:rand(160,cfg.viewW-160), y:cfg.viewH+60, vx:rand(-160,160), vy:-rand(700,1100), radius:36, emoji:entry.emoji, img:img, type:'power', power:entry.name, spin:rand(-4,4) }); fruits.push(f); }

/* ---------- Game Loop & draw ---------- */
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const livesEl = document.getElementById('lives');

function update(dt){
  if(paused) return;
  lifeCooldown = Math.max(0, lifeCooldown - dt);
  if(comboTimer > 0) comboTimer -= dt; else combo = 0;
  if(slowTimer > 0) slowTimer -= dt;
  if(doubleTimer > 0) doubleTimer -= dt;
  if(slowTimer <= 0){ slowTimer = 0; const i = powerups.indexOf('slow'); if(i!==-1) powerups.splice(i,1); }
  if(doubleTimer <= 0){ doubleTimer = 0; const i = powerups.indexOf('double'); if(i!==-1) powerups.splice(i,1); }

  lastSpawn += dt * (slowTimer > 0 ? 0.55 : 1);
  if(lastSpawn >= spawnInterval){
    lastSpawn = 0;
    spawnPattern();
    spawnInterval = Math.max(0.45, spawnInterval * Math.pow(0.992, wave*0.05));
    wave += 0.02;
  }

  const slowFactor = slowTimer > 0 ? 0.75 : 1;
  for(let i=fruits.length-1;i>=0;i--){
    const f = fruits[i];
    if(!f.alive){ fruits.splice(i,1); continue; }
    f.update(dt * slowFactor);
    if(f.y - f.radius > cfg.viewH + 100){
      if(f.type === 'fruit') lives = Math.max(0, lives - 1);
      f.alive = false; fruitPool.release(f); fruits.splice(i,1);
    }
  }

  for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.update(dt); if(!p.alive){ particlePool.release(p); particles.splice(i,1); } }

  scoreEl.textContent = `Score: ${score}`;
  comboEl.textContent = `Combo: x${1 + Math.floor(combo/5)}`;
  livesEl.textContent = `Lives: ${lives}`;

  if(lives <= 0){ running = false; paused = true; document.getElementById('pauseBtn').textContent = 'Restart'; addScore(score); showToast('Game Over ‚Äî score saved'); }
}

function draw(){
  ctx.clearRect(0,0,cfg.viewW,cfg.viewH);
  // fruits
  for(const f of fruits) f.draw(ctx, useImages);
  // particles
  ctx.fillStyle = 'rgba(255,200,80,0.9)';
  for(const p of particles) p.draw(ctx);
  // trail
  if(pts.length > 1){
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    for(let i=0;i<pts.length-1;i++){
      const a = pts[i], b = pts[i+1];
      const age = (pts.length - i)/pts.length;
      ctx.strokeStyle = `rgba(0,255,213,${0.16 * age})`;
      ctx.lineWidth = 6 * age + 1;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
  }
  // game over overlay
  if(!running){
    ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,0,cfg.viewW,cfg.viewH);
    ctx.fillStyle = '#fff'; ctx.textAlign='center';
    ctx.font='42px sans-serif'; ctx.fillText('Game Over', cfg.viewW/2, cfg.viewH/2 - 18);
    ctx.font='18px sans-serif'; ctx.fillText('Press Restart to try again', cfg.viewW/2, cfg.viewH/2 + 22);
  }
}

/* ---------- Main loop ---------- */
function loop(){
  const t = performance.now()/1000;
  let dt = Math.min(0.033, t - lastTime);
  lastTime = t;
  if(running && !paused) update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- UI helpers ---------- */
function showToast(msg){ const el = document.getElementById('toast'); el.textContent = msg; el.style.display = 'block'; setTimeout(()=>el.style.display='none', 1200); }

/* ---------- Buttons & Eruda ---------- */
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  if(!running && paused){ restart(); return; }
  paused = !paused; document.getElementById('pauseBtn').textContent = paused? 'Resume' : 'Pause';
});
document.getElementById('restartBtn').addEventListener('click', restart);
document.getElementById('boardBtn').addEventListener('click', ()=>{ renderBoard(); document.getElementById('boardModal').style.display = 'flex'; });
document.getElementById('closeBoard').addEventListener('click', ()=>document.getElementById('boardModal').style.display='none');
document.getElementById('resetBoard').addEventListener('click', ()=>{ localStorage.removeItem(BOARD_KEY); renderBoard(); showToast('Leaderboard reset'); });

document.getElementById('themeBtn').addEventListener('click', ()=>{ applyTheme((themeIndex+1)%THEMES.length); });
let themeIndex = 0; function applyTheme(idx){ themeIndex = idx; const t = THEMES[themeIndex]; bgLayer.style.background = t.css; bgLayer.style.backgroundSize = t.id==='wood' ? '256px 256px, cover' : 'cover'; document.getElementById('themeName').textContent = `Theme: ${t.name}`; }

document.getElementById('imagesToggle').addEventListener('click', ()=>{
  useImages = !useImages;
  document.getElementById('imagesToggle').textContent = `Use Images: ${useImages ? 'ON' : 'OFF'}`;
  showToast(useImages ? 'Images enabled' : 'Images disabled');
});

/* ---------- Start / restart ---------- */
function restart(){
  fruits.forEach(f => fruitPool.release(f)); fruits = [];
  particles.forEach(p => particlePool.release(p)); particles = [];
  score = 0; combo = 0; comboTimer = 0; lives = 3;
  spawnInterval = cfg.spawnInterval; wave = 1; lastSpawn = 0; lifeCooldown = 0;
  running = true; paused = false; document.getElementById('pauseBtn').textContent = 'Pause';
}

/* ---------- Preload + init ---------- */
async function startGameFlow(){
  // show loader and attempt to preload
  try{
    await preloadAll();
    // loader hides inside preloadAll
    showToast('Images preloaded (missing = emoji fallback)');
  }catch(e){
    console.warn('Preload had issues', e);
    showToast('Image load error ‚Äî using fallbacks');
    loader.style.display = 'none';
  }
  // start main loop
  lastTime = performance.now()/1000;
  loop();
}
startGameFlow();

/* ---------- Eruda loader (Dev Console) ---------- */
const DevConsole = (() => {
  let loaded = false, visible = false;
  function load(){
    return new Promise((resolve, reject)=>{
      if(loaded){ resolve(); return; }
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/eruda';
      s.async = true;
      s.onload = ()=>{ try{ eruda.init(); loaded=true; visible=true; eruda.show(); showToast('Eruda loaded'); resolve(); }catch(e){ reject(e); } };
      s.onerror = ()=> reject(new Error('Failed to load eruda'));
      document.body.appendChild(s);
    });
  }
  return {
    toggle: async function(){
      try{
        if(!loaded){ await load(); return; }
        if(visible){ eruda.hide(); visible=false; showToast('Console closed'); }
        else { eruda.show(); visible=true; showToast('Console opened'); }
      }catch(e){ console.error(e); showToast('Console failed to load'); }
    }
  };
})();
document.getElementById('devBtn').addEventListener('click', ()=> DevConsole.toggle());

/* ---------- Start/stop control & initial settings ---------- */
// export a minimal API for console debugging
window.game = {
  fruits, particles,
  restart: () => restart(),
  toggleImages: () => { useImages = !useImages; document.getElementById('imagesToggle').textContent = `Use Images: ${useImages ? 'ON' : 'OFF'}`; }
};
</script>
</body>
</html>
