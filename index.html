<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sky Shot — Bullets Rotate With Direction</title>
<style>
  :root{--bg:#031229;--accent:#3ec7ff;--accent2:#7b61ff}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Arial,Helvetica,sans-serif;overflow:hidden}
  #gameArea{position:relative;width:100vw;height:100vh;overflow:hidden;touch-action:none}

  /* HUD */
  #hud{position:absolute;left:12px;top:12px;z-index:300;display:flex;gap:10px;align-items:center}
  .panel{background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);font-weight:700}

  /* Player: positioned with left and bottom, uses transform to center horizontally */
  #player{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);width:66px;height:66px;border-radius:14px;background:linear-gradient(135deg,var(--accent),var(--accent2));z-index:200;display:flex;align-items:center;justify-content:center}

  /* bullet (img) moved by translate(x,y) + rotate(angle) */
  .bullet{position:absolute;left:0;top:0;width:48px;height:48px;pointer-events:none;z-index:220;will-change:transform,opacity;transform-origin:center center}
  .bullet.missing{width:18px;height:18px;border-radius:50%;background:#fff}

  .enemy{position:absolute;width:50px;height:50px;border-radius:10px;background:linear-gradient(180deg,#ff6666,#cc0033);z-index:150}

  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:10px;z-index:400}
  .bigBtn{padding:12px 24px;border-radius:12px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#001;font-weight:800}
</style>
</head>
<body>
<div id="gameArea">
  <div id="hud"><div class="panel">Score: <span id="score">0</span></div><div class="panel">High: <span id="highscore">0</span></div></div>

  <div id="player" aria-hidden="true">
    <svg viewBox="0 0 64 64" width="46" height="46"><path d="M32 6 L44 28 L32 22 L20 28 Z" fill="#fff" opacity=".16"/></svg>
  </div>

  <div id="overlay">
    <h2 style="margin:0">Sky Shot — Rotate Bullets</h2>
    <p style="margin:0;opacity:.8">Tap to start — bullets rotate in the travel direction.</p>
    <button class="bigBtn" id="startBtn">Start</button>
    <div style="font-size:12px;opacity:.75;margin-top:8px">Image path: <code>image/bullet.png</code></div>
  </div>
</div>

<script>
/* Config */
const BULLET_IMG = 'image/bullet.png';
const AUTO_FIRE_INTERVAL = 300;
const BURST_COUNT = 3;
const BURST_SPREAD = 14;
const MAX_BULLETS = 18;

/* DOM */
const gameArea = document.getElementById('gameArea');
const player = document.getElementById('player');
const startBtn = document.getElementById('startBtn');
const overlay = document.getElementById('overlay');
const scoreEl = document.getElementById('score');

/* State */
let state = { running:false, bullets:[], enemies:[], score:0, lastFire:0 };

/* Place player center */
function placePlayerCenter(){
  // keep left:50% and translateX(-50%) for responsive center; nothing required here
}
window.addEventListener('resize', placePlayerCenter);
setTimeout(placePlayerCenter,60);

/* Compute origin using offsetLeft/offsetTop relative to gameArea */
function getPlayerOriginUsingOffsets(){
  const px = player.offsetLeft + (player.offsetWidth / 2);
  const py = player.offsetTop;
  return { x: Math.round(px), y: Math.round(py) };
}

/* Angle helper: compute deg rotation for sprite pointing upward by default
   If your bullet image points to the right by default, remove +90 adjustment.
*/
function angleDegFromVector(vx, vy){
  // atan2 expects (y, x) -> gives radians; convert to degrees and rotate so 0 = up
  const rad = Math.atan2(vy, vx); // vy, vx
  const deg = rad * 180 / Math.PI;
  // our rocket image is oriented "up" visually — add 90 deg so vx=0,vy<0 -> angle=0
  return deg + 90;
}

/* Spawn single bullet at numeric coordinates (x,y are gameArea-relative),
   vx, vy are pixels per frame-unit (we scale in loop). We'll compute and apply rotation.
*/
function spawnSingleBulletAt(x, y, vx=0, vy=-14){
  if(state.bullets.length >= MAX_BULLETS){
    const old = state.bullets.shift();
    if(old && old.el && old.el.parentNode) old.el.remove();
  }
  const el = document.createElement('img');
  el.className = 'bullet';
  el.draggable = false;
  el.src = BULLET_IMG;
  el.onerror = ()=> el.classList.add('missing');

  // center image
  const w = 48, h = 48;
  const sx = x - w/2;
  const sy = y - h - 6; // a little gap so bullet appears above ship

  // compute initial rotation and set transform combining translate and rotate
  const ang = angleDegFromVector(vx, vy);
  el.style.left = '0px';
  el.style.top = '0px';
  el.style.transform = `translate(${sx}px, ${sy}px) rotate(${ang}deg)`;

  gameArea.appendChild(el);
  state.bullets.push({el, x: sx, y: sy, vx, vy});
}

/* Fire burst from player origin using offsets (adds small jitter) */
function fireBurstFromPlayer(){
  const origin = getPlayerOriginUsingOffsets();
  for(let i=0;i<BURST_COUNT;i++){
    const offset = (i - Math.floor(BURST_COUNT/2)) * BURST_SPREAD + (Math.random()-0.5)*4;
    const vx = offset * 0.03;
    const vy = -14 + (Math.random()-0.5)*1.6;
    spawnSingleBulletAt(origin.x + offset, origin.y + (Math.random()-0.5)*6, vx, vy);
  }
}

/* Loop: move bullets and update rotation while moving */
let lastFrame = performance.now();
function loop(ts){
  const dt = Math.min(40, ts - lastFrame);
  lastFrame = ts;
  if(state.running){
    if(ts - state.lastFire > AUTO_FIRE_INTERVAL){
      state.lastFire = ts; fireBurstFromPlayer();
    }

    // update bullets numeric position and rotation
    for(let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.x += b.vx * (dt/16.67);
      b.y += b.vy * (dt/16.67);
      // recompute angle each frame so it matches velocity (useful if vx/vy change)
      const ang = angleDegFromVector(b.vx, b.vy);
      b.el.style.transform = `translate(${b.x}px, ${b.y}px) rotate(${ang}deg)`;
      if(b.y < -200){
        if(b.el.parentNode) b.el.remove();
        state.bullets.splice(i,1);
      }
    }
  }
  requestAnimationFrame(loop);
}

/* start handlers */
startBtn.addEventListener('click', ()=> {
  overlay.style.display = 'none';
  state.running = true; state.score = 0;
  state.bullets.forEach(b=>{ if(b.el.parentNode) b.el.remove(); }); state.bullets = [];
  requestAnimationFrame(loop);
});

/* player move with touch/mouse — set player.left inline so offsetLeft works */
function setPlayerXFromClient(clientX){
  const rect = gameArea.getBoundingClientRect();
  const px = clientX - rect.left - player.offsetWidth/2;
  const clamped = Math.max(6, Math.min(gameArea.clientWidth - player.offsetWidth - 6, px));
  player.style.left = clamped + 'px';
}
gameArea.addEventListener('touchstart', e=>{ if(e.touches[0]) setPlayerXFromClient(e.touches[0].clientX); }, {passive:true});
gameArea.addEventListener('touchmove', e=>{ if(e.touches[0]) setPlayerXFromClient(e.touches[0].clientX); }, {passive:true});
gameArea.addEventListener('mousemove', e=>{ if(e.buttons) setPlayerXFromClient(e.clientX); });

/* optional manual tap firing */
gameArea.addEventListener('pointerdown', (e)=>{
  if(!state.running) return;
  // avoid firing when clicking overlay or controls in other versions
  if(e.target.closest('button')) return;
  fireBurstFromPlayer();
}, {passive:true});
</script>
</body>
</html>
